#+BEGIN_ABSTRACT
Writing and maintaining planning problems, specified in the widely
used /Planning Domain Definition Language/ (\textsc{pddl}), can be
difficult, time-consuming and error-prone. This thesis will present
\mypddl, a toolkit that helps knowledge engineers to develop,
visualize and manipulate \textsc{pddl} planning task specifications.
With \textsc{myPddl}, structured \textsc{pddl} projects can be created
and edited using code templates and syntax highlighting. One tool
visualizes the type hierarchy in \textsc{pddl} domains, allowing
knowledge engineers to understand the representation structure at a
glance and to also keep track of developments with a basic revision
control system. Another tool allows calculating distances between
objects specified by predicates in a problem file. These tools make
use of an interface that provides a general way for reading and
writing \textsc{pddl} specifications by using the programming language
Clojure, and thus presenting a means of bypassing \textsc{pddl}'s
limited modeling capacity. They are made accessible in the
customizable editor Sublime Text. A small user study, conducted with
eight inexperienced \textsc{pddl} users, shows some initial evidence
that the syntax highlighting feature and the automated creation of
type diagrams could support knowledge engineers in the design and
analysis process. The users detected ..% more errors using the syntax
highlighter in the same time as non-users and the average task
completion time for questions on a hierarchical domain was reduced by
..%.
#+END_ABSTRACT

* Introduction
<<ch:introduction>>

Have you ever struggled to find the optimal sequence of actions for a
recurrent problem? While a task like this could take you hours, weeks
or even a lifetime to complete, a planning software could possibly get
the job done within milliseconds. Being a key aspect of artificial
intelligence, planning is concerned with devising a plan, that is a
sequence of actions, to achieve a desired goal
\cite{helmert2008understanding}. It can be both a tool to create
automated systems and a means to support and understand human behavior
\cite{konar1999artificial}. However, the effectiveness of planning
largely depends on the quality of the problem formalization
\cite{shah2013knowledge,keps2014}. The Planning Domain Definition
Language (\textsc{pddl}) \cite{mcdermott1998pddl} is a formal language
and the de facto standard for the description of planning tasks
\cite{ilghami2005extension}. The discipline that deals with the
integration of world information into a computer system via a human
expert is called knowledge engineering \cite{feigenbaum1983fifth}. To
lay the foundations for this thesis, a basic introduction to and
design principles for \pddl will be given in Chapter [[ch:basics]].
Creating these planning task specifications is a complex task that can
be error-prone and time consuming. It requires the analysis of the
underlying problem itself and the systematic use of appropriate tools
specialized for developing planning task specifications
\cite{shah2013knowledge}. Therefore, developing tools for \pddl and
hence facilitating the knowledge engineering process is worthwhile.

#+BEGIN_SRC text
;; Logistics domain, PDDL 3.1 version.

(define (domain logistics-object-fluents)

(:requirements :typing :equality :object-fluents)

(:types package place city - object
        vehicle location - place
        airport - location
        truck airplane - vehicle)

(:functions (city-of ?l - location) - city
            (vehicle-location ?v - vehicle) - location
            (package-location ?p - package) - place)

(:action drive
         :parameters    (?t - truck ?l - location)
         :precondition  (= (city-of (vehicle-location ?t)) (city-of ?l))
         :effect        (assign (vehicle-location ?t) ?l))

(:action fly
         :parameters    (?a - airplane ?l - airport)
         :effect        (assign (vehicle-location ?a) ?l))

(:action load
         :parameters    (?p - package ?v vehicle)
         :precondition  (= (package-location ?p) (vehicle-location ?v))
         :effect        (assign (package-location ?p) ?v))

(:action unload
         :parameters    (?p - package ?v - vehicle)
         :precondition  (= (package-location ?p) ?v)
         :effect        (assign (package-location ?p) (vehicle-location ?v)))

)
#+END_SRC

The modular toolkit \mypddl (\textit{m}odeling efficientl\textit{y}
\pddl was developed, within the scope of this thesis, in order to
tackle frequent needs of knowledge engineers, like project management,
efficient development, error-detection, team collaboration features
and to increase the acceptance and usage of \pddl in real-world
domains \cite{shah2013knowledge,keps2014}. Existing tools will be
critically reviewed in Chapter [[ch:related]] to set the goals for
\mypddl.

\mypddl is intended to support knowledge engineers throughout the
entire design cycle of specifying planning tasks. In the initial
stages, it allows for the creation of structured \textsc{pddl}
projects that should support a disciplined design process. With the
help of snippets, i.e. code templates, often used constructs can be
inserted in \textsc{pddl} files. A syntax highlighting feature that
supports a faster error-detection and aids with understanding parts of
planning tasks at a glance can come in handy in intermediate stages.
Understanding the textual representation of complex type hierarchies
in domain files can be confusing, so an additional feature enables
their visualization. \textsc{pddl}'s limited modeling capabilities
were bypassed by developing a interface that supports the conversion
of \textsc{pddl} code into Clojure \cite{hickey2008clojure} code and
vice versa. One use case for such an interface could be the partial
automation of modeling tasks. Within this project, the interface was
used for a feature that calculates distances between objects specified
in a problem model. All of these features were integrated into the
customizable and extensible Sublime Text \cite{sublimetext2} editor.
They are described in detail in Chapter [[ch:tools]]. Since the main aim
in the development of the toolkit was for it to be easy to use and
maintain, it is evaluated with regard to these criteria in Chapter
[[ch:evaluation]]. The usability was assessed by means of a user test with
eight subjects that had no prior experience with artificial
intelligence planning. The results indicate that both error-detection
and the understanding of a given domain can be facilitated by \mypddl.
Finally, the implications are briefly discussed before an outlook for
future research and developments in the field concludes this thesis in
Chapter [[ch:conclusion]].

* Background and Basics
<<ch:basics>>

The human brain is an astonishing structure that allows us to get by
in a highly complex world and give more or less rational reasons for
our past or planned actions. While computer systems are yet to fully
master these skills, the study of artificial intelligence tries to
narrow this gap \cite{akerkar2012intelligent}. For this purpose,
constructs are needed that can represent the information about the
world and the problem. In automated planning, this is usually done
\cite{fox2003pddl2} using a planning language, like \textsc{pddl}.

To illustrate the usage and basics of \textsc{pddl}, the remainder of this
section presents a modeling walkthrough using a fictional example.

Consider the following world that is to be integrated into a computer
system using \textsc{pddl}:

#+BEGIN_QUOTE
/Hacker World/ \\
If hackers are hungry, they have to eat some pizza in order to be able
to work, that is to exploit (or hack into) vulnerable software.
#+END_QUOTE
In this description, we can identify several constructs that should
somehow be integrated into the computer. There are:

- Types of entities:  :: The world consists of hackers, software and pizza.
- Logical states: :: Hackers can be hungry or not, software can be
     vulnerable or not, software can be exploited or not.
- Actions: :: Hackers can exploit software and they can eat pizza.
This description of a world can be specified in \textsc{pddl} using a
domain file. The domain file can be compared to a stage setting,
providing the framework for a specific problem scenario by way of
general, abstract constructs and conditions.

In the world of hackers and pizzas, such a domain specific problem
could be:

#+BEGIN_QUOTE
/Gary's Huge Problem/ \\
Gary is a hungry hacker who should somehow exploit the vulnerable
software MagicFailureApp. Some pepperoni pizza is lying around.
#+END_QUOTE
Again, several constructs can be identified:

- Objects :: The hacker Gary (in \textsc{pddl} all entities are
             objects, including persons), the pepperoni pizza, the
             software.

- Initial state :: Gary is hungry and the software 'MagicFailureApp'
                   is vulnerable.

- Goal state :: The MagicFailureApp is exploited.
Assume that Gary wants the help of an automated planning system to
plan the sequence of required actions (/Who has to eat pizza?/, /What
should be hacked?/ and /In what order should these things be done?/),
leading from the initial state to the goal state. These specifications
must be formalized so that a planner can utilize them. In
\textsc{pddl}, this is done in problem files. In the end, Gary will be
able to feed the domain and the problem file into a planner which will
generate a sequence of actions that Gary can take to solve his
problem. Summing up, \textsc{pddl} planning tasks are composed of two
separate, corresponding files:

- Domain file: :: General, problem-independent description of types,
                 predicates (logical states) and actions.

- Problem file: :: Specification of a concrete problem within a
                  particular domain, expressed by the initial state
                  and the goal state. Specific values are assigned to
                  the templates provided by the domain file
                  (instantiation). 
This separation allows for a powerful task modeling process: while
general world information is described in the domain file, specific
instances of problems are created in the problem files. This means
that one abstract model of a world can be used for solving many
problem instances. Figure \ref{workflow} (TODO: Add figure) visualizes
the workflow for planning in \textsc{pddl}.

The rest of this section is to propose general design guidelines for,
and give an introduction to \textsc{pddl} [fn:5], to serve as a basis
for the rest of this thesis. To this end, the syntax of common
constructs of domain and problem files is further investigated in a
step-by-step approach, continuing with the above described example.

[fn:5] More complete descriptions of \textsc{pddl}, as well as
formulations in Backus-Naur form (BNF) are provided by
\textcite{fox2003pddl2} for \textsc{pddl} 2.2 and
\textcite{kovacs2011bnf} for \textsc{pddl} 3.1.

** Analysis

How do you begin to model a planning task? The first, and possibly
most significant step to integrate information into a computer system,
is gaining an /understanding/ of the problem
\cite{polya2008solve,helmert2008understanding}. For modeling in
\textsc{pddl}, the following six general design principles ought to
lead to a thorough, stepwise, and iterative modeling process:

- Analysis: :: Every task specification should begin with an analysis
               of the informal world and the problem statement. In
               this design step, one determines relevant types,
               adequate examples and identifies both the initial and
               the goal state.

- Type diagram: :: Based on the preceding analysis, the relationship
                   of the identified categories or types is
                   represented, using a diagram. This can be done on
                   paper or with the help of a graph editor.

- Domain definition: :: In this step, the diagrams are translated into
     \textsc{pddl}. Furthermore predicates and actions are declared.

- Problem definition: :: After completing the domain definition,
     objects can be instantiated in the problem file. The initial and
     goal states are modeled using the predicates declared in the
     domain file.

- Planning: ::  Now, one can provide the domain and problem definition
                to a planner. The planner then generates a plan, i.e. a
                sequence of actions that leads to the goal state.

- Plan analysis: :: Finally, the generated plan needs to be inspected.
                    If any design mistakes or inconistencies are
                    detected, it is advisable to restart at an earlier
                    design step.

The following two sections deal with the creation of a domain and
problem definition. At the end of the introduction of each construct,
the corresponding code block of the /Hacker World/ and /Gary's Huge
Problem/ is given.

** Domain File

The domain file sets the framework for planning tasks. It models the
world in which the problem occurs and hence determines which types and
predicates are available and which actions are possible.

***  Domain Definition

We begin with the definition of the domain file. Every domain file
starts with =(define (domain DNAME) ...)=, where =DNAME= specifies the
name of the domain. A semicolon (=;=) declares the rest of the line as
comment.

#+CAPTION: The domain definition of the /Hacker World/
#+BEGIN_SRC text
; Hacker World - A realistic example
(define (domain hacker-world)
#+END_SRC


*** Requirements

\pddl is composed of feature subsets \cite{mcdermott1998pddl}.
As most planners only support some of these subsets, the requirements
block is useful for a planner to determine if it can act on a given
problem. While basic specifications are used by default
\cite{mcdermott1998pddl}, further requirements have to be stated
explicitly. For example, one requirement used by many planning domains
\cite{wickler2011using} is:

- :typing :: Enables the typification of variables (see
             [[subsubsec:types]] Types
             below), so that it is mandatory for variables to be of a
             particular type.

Besides =:typing=, the /Hacker World/ will use a further
requirement:

- :negative-preconditions ::  Allows for the specification of negative
     preconditions in actions, so that an action can only be executed
     if a predicate is not true initially.

#+CAPTION: The requirements that are necessary to model the /Hacker World/
#+BEGIN_SRC text
(:requirements :typing
               :negative-preconditions)
#+END_SRC

*** Types
<<subsubsec:types>>
Often in the real-world, there will be individual objects of the same
kind or type. There may be many different desks, but all share
common properties, like having a flat upper surface, and all are
pieces of furniture.

\pddl allows for declaring types and thereby structuring the
domain in the =(:types ...)= block. Relations can be expressed with a
type hierarchy, in which any type can be a subtype of yet another
type. Typed lists are used to assign types to variables.
Parameters in actions, as well as arguments in predicates can be typed
in this manner. Later, in the problem file, objects are assigned to
types. Types are declared using a list of strings, followed by a
hyphen (=-=), followed by the higher-level type. Every \pddl
domain includes the built-in types =object= and =number=, and every
defined type, in turn, is a subtype of =object=.

#+CAPTION: The type hierarchy for the /Hacker World/, consisting of different
#+CAPTION: types of persons, furniture, computers, hackers, and software.
#+CAPTION: The elements on the left-hand side
#+CAPTION: (for example =hacker non-hacker=) are declared subtypes of the right-hand
#+CAPTION: side (=person=) whereby the type hierarchy is expressed. 
#+BEGIN_SRC text
  (:types hacker non-hacker - person
          desk chair - furniture
          laptop workstation - computer
          pizza burgers fries - food
          pepperoni supreme - pizza
          food person furniture software - object)
#+END_SRC

*** Predicates

How can we describe properties of objects and states of the world?
Predicates are templates to represent logical facts and can be either
true or false. In the =:(predicates ...)= block, predicate names and
the number of arguments together with the corresponding types are
declared. The general syntax for a predicate is =(pname ?v1 - t1 ?v2 -
t2 ...)=, where =?= followed by a name (=v1=, =v2=) declares a
variable, and the expression (=t1=, =t2=) following the hyphen (=-=)
states the type of this variable. All the types that are used must be
declared in the typing section first. The number of variables (or
arguments) determines the arity of a predicate ranging from zero
(nullary predicate) to any positive integer (n-ary predicate). Type
assignments for variables that have the same type and are declared
side by side can be grouped, meaning that =(p ?v1 - t ?v2 - t)= is
equivalent to =(p ?v1 ?v2 - t)=.

#+CAPTION: This section declares
#+CAPTION: five predicates: the unary predicates
#+CAPTION: =hungry=, =vulnerable= and =exploited=, the binary predicate =has=,
#+CAPTION: and the 3-ary predicate =location= that specifies x and y coordinates for a furniture item.
#+BEGIN_SRC text
(:predicates (has ?s - software ?p - person)
             (hungry ?p - person)
             (vulnerable ?s - software)
             (exploited ?s - software)
             (location ?f - furniture ?x ?y - number)
#+END_SRC

*** Actions

Now that we have predicates for describing world states, we still need
a means for changing their value. This is done with action. Actions
are operators in \textsc{pddl}, because they can change properties of
objects by changing predicate values, so that problems can be solved.
Actions usually consist of three parts:

- :parameters :: A (typed) argument list that determines which
                 variables can be used in the precondition and effect
                 part.

- :precondition :: A combination of predicates, all of which must be
                   true before an action can be executed. Therefore,
                   this part describes the applicability of an action.

- :effect :: Specifies the new values of the declared predicates, once
             the action has been completed. Therefore, it describes
             the post-condition of an action.

#+CAPTION: Three actions that can change logical values in the /Hacker World/. 
#+CAPTION: It is important to remember  that  predicate values keep being
#+CAPTION: true if an effect adds a logical fact. This is often not desired.
#+CAPTION: Consider the action move, that changes the location of a chair.
#+CAPTION: Only having the effect =(location chair ?new-x ?new-y)= would result in
#+CAPTION: the chair being located at two locations, at =?old-x= and =?old-y=
#+CAPTION: and the new, specified coordinates. Therefore, the old coordinates have to be
#+CAPTION: deleted, using =(not ...)=. 
#+BEGIN_SRC text
;; Eat a delicious pizza (:action eat-pizza
  :parameters (?pi - pizza ?p - person)
  :precondition (hungry ?p)
  :effect (not (hungry ?p)))

;; Exploit vulnerable software of a victim
(:action exploit        
  :parameters (?h - hacker ?s - software ?p - person)
  :precondition (and (has ?s ?p)
                     (vulnerable ?s)
                     (not (hungry ?h)))
  :effect (exploited ?s))

;; Move a piece of furniture
(:action move
  :parameters (?f - furniture ?old-x ?old-y ?new-x ?new-y)
  :precondition ()
  :effect (and (location ?f ?new-x ?new-y)
               (not (location ?f ?old-x ?old-y)))))
#+END_SRC

** Problem File

A planning problem consists of a domain and a corresponding problem
file. Within problem files, concrete objects are created
(instantiated). Furthermore, the initial world state and the desired
goal state that is to be reached are declared.

*** Problem Definition 

Analogous to the domain definition, problem files are initiated with
=(define (problem PNAME) ...)=, where =PNAME= declares the name of the
problem.

#+CAPTION: Initiating the problem file with the name garys-huge-problem
#+BEGIN_SRC text
(define (problem garys-huge-problem)
#+END_SRC
 
*** Associated Domain

Problems occur in worlds. Therefore, problem files are designed with
regard to domain files that need to be referenced at this point in the
problem file. This means that =DNAME= in =(:domain DNAME)= and =DNAME=
in =(define (domain DNAME) ...)= in the corresponding domain file have
to be identical.

#+CAPTION: The domain "hacker-world" is
#+CAPTION: the corresponding domain name to the problem garys-huge-problem
#+BEGIN_SRC text
(:domain hacker-world)
#+END_SRC


*** Objects

Since types are only empty shells, they need to be instantiated. This
is done in the =(:objects ...)= block. Instantiating types means that
concrete objects are assigned to the types.

#+CAPTION: This part assigns concrete objects to the type
#+CAPTION: templates. In this case, magicfailureapp - software means that the
#+CAPTION: object magicfailureapp is of the type application.
#+BEGIN_SRC text
  (:objects big-pepperoni - pepperoni
            gary - hacker
            gisela - non-hacker
            magicfailureapp - software)
#+END_SRC


***  Init

The =(init ...)= block models the initial state of the world with a
list of instantiated predicates that are declared as true. All other,
non-specified predicates are assumed to be false. This is called the
/closed-world assumption/ [fn:4].

#+CAPTION: The initial situation in Gary's Huge Problem consists of the hungry
#+CAPTION: hacker Gary and the vulnerable application MagicFailureApp that
#+CAPTION: belongs to Gisela.
#+BEGIN_SRC text
  (:init (hungry gary)
         (vulnerable magicfailureapp)
         (has magicfailureapp gisela))
#+END_SRC

[fn:4] By specifying =:open-world= in the requirements part, \textsc{pddl} is
also capable of using the open world assumption, where non-specified
predicates can be both, true or false.


***  Goal

The goal state is described by the logical fact that is desirable and
should be reached with the execution of the plan. In \textsc{pddl},
several goals are combined with =(and ...)=. All unspecified predicates
are irrelevant, meaning that they can be either true or false in the
goal state.

#+CAPTION: In the end, the software magicfailureapp
#+CAPTION: should be exploited.
#+BEGIN_SRC text
(:goal (exploited magicfailureapp)
#+END_SRC

** Planning

Finally, the effort of the formalization of the planning task will be
rewarded with the automatic generation of a plan. There is a broad
range of available planners [fn:6]. However, most planners only
support certain subsets of \textsc{pddl} and have some
peculiarities [fn:3]. Additionally, the quality of error messages is
very diverse, ranging from stating that an error occurred to
displaying line number and found problem.

This thesis uses the planner SGPlan_5 \cite{hsu2008sgplan}, a planner
that supports many \textsc{pddl} features and has comprehensive
error messages that state the actual problem [fn:9].

The planner SGPlan_5 can be used by specifying the domain file and
the problem file in a command line interface.

The relevant output lines for /Gary's Huge Problem/, specified in the
/Hacker World/ look as follows:
\vspace*{0.2cm}

#+BEGIN_SRC text
0.001: (EAT-PIZZA BIG-PEPPERONI-PIZZA GARY) [1]
1.002: (EXPLOIT GARY MAGICFAILUREAPP GISELA) [1]
#+END_SRC

The numbers to the left (=0.001=, =1.002=) and to the right (=[1]=)
specify the start time and the duration of the actions, respectively.
Since we did not use any timestamps, they are dispensable in this
case, because only the order of actions is relevant.

Gary now definitely knows that he first has to eat the pepperoni pizza
before he can exploit Gisela's application MagicFailureApp.

Since specifying \textsc{pddl} files can be time-consuming the next
chapter will compare knowledge engineering tools that support the user
in effectively eneffective planning model.

[fn:6] For an overview of planners that participated in the 2011
International Planning Competition and their features, see
http://www.plg.inf.uc3m.es/ipc2011-deterministic/ParticipatingPlanners.html.

[fn:3] A short discussion on planners and their "excentricities" can
be found at http://users.cecs.anu.edu.au/~patrik/pddlman/writing.html.

[fn:9] Additionally, SGPlan_5 was the winner of the 1st Prize
Satisficing Planning in the Deterministic Part of the International
Planning Competition (IPC) in 2006
http://zeus.ing.unibs.it/ipc-5/results.html.


* Related Work
<<ch:related>>

This chapter is to introduce knowledge engineering tools that allow
editing \textsc{pddl} files in a textual environment to some extent.
All tools provide features to support the user in writing correct
\textsc{pddl} code more efficiently. After introducing the tools, they
are compared and their shortcomings are discussed to set the stage for
\mypddl.

** PDDL Studio

\pddlstudio \cite{chomuttool,plch2012inspect} is an application for
creating and managing \textsc{pddl} projects, i.e. a collection of
\textsc{pddl} files. The \pddlstudio integrated development
environment (IDE) was inspired by Microsoft Visual Studio
\cite{visstudio} and imperative programming paradigms. Its main
features are syntax highlighting, error detection, context sensitive
code completion, code folding, project management, and planner
integration. Many of these features are based on a parser, which
continuously analyzes the code and divides it into syntactic elements.
These elements and the way in which they relate to each other can then
be identified. The syntax highlighter is a tool that colors constructs
according to their syntactical meaning within the code. In the case of
\pddlstudio, it colors names, variables, errors, keywords, predicates,
types and brackets each in a different customizable color.
\pddlstudio's error detection can recognize both syntax errors
(missing keywords, parentheses, etc.) and semantic errors (wrong type
of predicate parameters, misspelled predicates, etc.). Since semantic
errors can be of an interfile nature, meaning that there is a mismatch
between domain and problem file, \pddlstudio can detect such errors in
real time. The code completion feature allows for the selection of
completion suggestions for standard \textsc{pddl} constructs as well
as for terms that have been used before within this file or other
files in the same project. Code folding allows the knowledge engineer
to hide certain code units or blocks that are currently not needed.
Only the first line of the block is then displayed. \pddlstudio's code folding feature works on the basis of syntax. This means
that it can tell different code blocks apart with the help of the
parser and is thus able to fold the code accordingly. All these above
mentioned features of \pddlstudio utilize the parser. Another
important feature of the \pddlstudio project is a project
manager. This keeps track of all files, displays them in a tree
structure, saves them upon compilation and is also necessary for the
interfile error detection and code completion functionalities. Lastly,
a command-line interface allows the integration of planners in order
to run and compare different planning software.

** itSIMPLE

Unlike \pddlstudio, which provides a text based editor for \pddl, the
\itsimple \cite{vaquero2005itsimple} editor has, as its main feature, a
graphical approach that allows for designing planning tasks in an
object-oriented approach using Unified Modeling Language (\textsc{uml})
\cite{booch1999unified} diagrams. \textsc{uml} was invented in order
to standardize modeling in software engineering (SE) and the latest
version (\textsc{uml} 2.4.1) \cite{umllatest} consists of 14 different types of diagrams
divided into two larger groups: structure and behavior diagrams. In
the process leading up to \itsimple, \textsc{uml.p} (\textsc{uml} in a
Planning Approach) was proposed, a \textsc{uml} variant specifically
designed for modeling planning domains and problems
\cite{vaquero2006use}.

This variant specifies:

- Class Diagrams for static domain features
- Object Diagrams to describe the initial and the goal state in
  problem specifications
- StateChart Diagrams to represent dynamic characteristics such as
  actions in domain specifications.

Thus, \itsimple uses both \textsc{uml} structure diagrams (Class and
Object Diagrams) and \textsc{uml} behavior diagrams (StateChart
Diagrams). The main purpose of \itsimple is supporting knowledge
engineers in the initial stages of the design phase by making tools
available that help with the transition from the informality of the
real world to the formal specifications of domain models. The
professed aim of the project is to provide a means to a
\enquote{disciplined process of elicitation, organization and analysis
of requirements} \cite{vaquero2005itsimple}. However, subsequent
design stages are also supported. Once domain and problem models have
been created, \textsc{pddl} representations can be generated from the
UML.P diagrams, edited, and then used as input to a number of
different integrated planning systems. Therefore, one of the tools
already introduced within the scope of \pddlstudio, planner
integration, is also implemented. However, unlike in \textsc{pddl}
Studio, \itsimple has a more user-friendly approach to planner
integration: domain and problem can be fed to the planner with the
press of a button, while in \textsc{pddl} Studio, the user has to know
and input commands in a command-line interface.

Not only is it possible to directly input the domains and problems
into a planner, another tool can inspect the output from the planning
system using the built-in plan analysis. This consists of a plan
visualization that shows the interaction between the plan and the
domain by highlighting every change caused by an action. \itSimple's
modeling workflow is unidirectional, as changes in the \textsc{pddl} domain do
not affect the UML model and UML models have to be modeled manually,
meaning that they cannot by generated using \textsc{pddl}. Starting in version
4.0 \cite{vaquero2012itsimple4} \itsimple expanded its features to
allow the creation of \textsc{pddl} projects from scratch (i.e. without UML to
\textsc{pddl} translation process). Thus far, the \textsc{pddl} editing features are
basic. A minimal syntax highlighting feature recognizes \textsc{pddl} keywords,
variables, and comments. Furthermore, \itsimple provides templates for
\textsc{pddl} constructs, such as requirement specifications, predicates,
actions, initial and goal definitions.

** PDDL-Mode for Emacs
GNU Emacs is a text editor, primarily written in, and customizable by
using Emacs Lisp (TODO!), a Lisp dialect
\cite{stallman1981emacs,lewis1990gnu}. The core values of Emacs are
its extensibility and customizability. \pddlmode \cite{pddlmode} is a
major Emacs mode, which determines the editing behavior of Emacs, for
browsing and editing \textsc{PDDL} files. It provides syntax
highlighting by way of basic pattern matching of keywords, variables
and comments. Additional features are automatic indentation and code
completion as well as bracket matching. Code snippets for the creation
of domains, problems and actions are also available. Finally, the
\pddlmode keeps track of action and problem declarations by adding
them to a menu and thus intending to allow for easy and fast code
navigation.

** Critical Review

All three tools, that have been described above, provide environments
for the creation of \pddl code. However, each comes with its own
advantages and disadvantages that are to be reviewed in this section.
At the end of each discussed feature, the approach that will be used
in \mypddl is introduced.

First and foremost, it must be mentioned that both \pddlstudio and
\itsimple were made from scratch, i.e. they do not build on existing
editors and therefore cannot fall back on refined implementations of
features that have been modified and improved many times throughout
their existence. Many of their features must be regarded against this
backdrop.

For instance, \pddlstudio has a parser implemented that enables code
folding on a syntactical basis. \pddl-mode for Emacs, on the other
hand could be customized to be capable of code folding either on the
basis of indentation or on a syntactic level. Not providing a simple
way to automatically indent code is one of the drawbacks of
\pddlstudio and \itsimple, since \enquote{in a large program, no
indentation would be a real hindrance and very difficult to use. The
same is true for overly indented programs.} \cite{miara1983program}.
Furthermore, both \itsimple and \pddlstudio specify horizontal tab
sizes of about ten spaces, while two to four spaces generally seem to
be adequate \cite{miara1983program}. To have both basic editor
features [fn:2] and a high customizability, it was decided to use an
existing, extensible text editor to integrate \mypddl into.

The tools can also be compared in terms of their syntax highlighting
capabilities. In \pddlmode for Emacs, keywords (up to \pddl 2.2),
variables, and comments are highlighted. However, this is only done
via pattern matching without controlling for context. This means that
wherever the respective terms appear within the code they will get
highlighted, regardless of the syntactical correctness. Therefore, it
is useful when the knowledge engineer is familiar with \pddl syntax,
but can also be misleading if this is not the case. Different colors
can be chosen by customizing Emacs. \itsimple's syntax highlighting
for \pddl 3.1 is, except for the \pddl version difference, equally as
extensive as that of \pddlmode for Emacs, but does not allow for any
customization. Despite placing a larger emphasis on the creation of
\pddl code from scratch within the \itsimple modeling environment,
syntax highlighting did not get more advanced with the latest version.
\pddlstudio has advanced syntax highlighting that distinguishes all
different \pddl \smallerft[0.8]{1.2} constructs, depending on the context, and allows
knowledge engineers to choose their preferred highlighting colors. One
of the primary objectives of \mypddl is to help users in keeping track
of their \pddl programs. As a means to this end, it was decided to
also implement sophisticated, context-dependent syntax highlighting.

Another feature that can be useful for fast programming, is the
ability to insert larger code skeletons or snippets. This allows the
knowledge engineer to focus on the specific domain and problem
characteristics instead of having to worry about the \pddl
formalities. \pddlstudio does not support the insertion of code
snippets at all. \itsimple features some code templates for
predicates, derived predicates, functions, actions, constraints,
types, comments, requirements, objects, and metrics. However, the
templates are neither customizable nor extensible. \pddlmode for Emacs
provides three larger skeletons, one for domains, one for problems and
one for actions. Further skeletons could be added. \mypddl aims to
combine the best of these latter tools and support customizable and
extensible snippets for domains, problems, types, predicates,
functions, actions and durative actions. In addition, to allow users
to easily navigate within snippets, the option of going from one blank
to the next by pressing \keys{\tab} (tab key) on the keyboard is also provided.

When it comes to visualization, neither \pddlstudio nor \pddlmode for
Emacs provide any visualization options. \itsimple, on the other hand,
is based entirely on visually modeling domains and problems.
Therefore, since the first version, the focus has mainly been on
exporting from \textsc{uml.p} to \pddl. \mypddl is to reverse this
design approach and enable type diagram visualization of some parts of
the \pddl code.

At this point, it must be mentioned that
\textcite{tonidandel2006reading} present a translation process, from a
\pddl domain specification to an object-oriented \textsc{uml.p} model
as a possible integration for \itsimple. This translation process
makes extensive semantic assumptions for \pddl descriptions. Two
default classes /Agent/ and /Environment/, corresponding to \pddl
types, are incorporated into the Class Diagram. The first parameter in
the =:parameters= section of an action is automatically declared as a
subclass of the class /Agent/. In addition, each action will be
allocated to the corresponding class of its first parameter in the
Class Diagram. Furthermore, the first argument of a predicate is
considered to be its main argument, so depending on their arity,
predicates would be visualized differently:

- Nullary predicates would be allocated as attributes of the type
  /Environment/.
- Unary predicates would be declared as attributes of the type of the
  specified parameter.
- Binary predicates would be regarded as associations, expressed by an
  labeled arrow from the type of the first parameter to the type of
  the second one.

The described method is limited, because predicates with an arity of
three or higher cannot be visualized. There is currently no \itsimple
version with this feature, according to an email from one of the
authors, Tiago Vaquero, dated March 11 2014. This approach makes
relatively large semantic assumptions that could distort the
visualization. In contrast, \mypddl allocates predicates to every
mentioned type in the variable list, and therefore allows for a
representation of arbitrary n-ary predicates (n > 0). Actions are not
visualized in \mypddl.

Searching for errors can be one of the most time consuming parts of
the design process \cite{gill1951diagnosis}. Hence, any tool that is
able to help detect errors faster is of great value to the knowledge
engineer. While \pddlmode for Emacs and \itsimple facilitate error
detection only by basic syntax highlighting, \pddlstudio not only has
syntactic but also semantic error detection implemented. Errors are
detected immediately when they are made, thanks to the parser, and a
dynamic table keeps track of them and provides error descriptions.
Even though the immediacy with which errors are highlighted and added
to the table can be helpful, it can also be premature at times. For
example just because the closing parenthesis was not typed yet, does
not mean it was forgotten. Therefore, for \mypddl the goal was to
implement a more subtle syntactic error detection. Syntactic errors
are simply not highlighted by the syntax highlighting feature, while
all correct \pddl code is highlighted. Even though checking for
semantic errors online should allow finding such errors before feeding
the program to a planner, and thus increase the probability of feeding
correct files to the planner, planning software is also able to detect
semantic errors. For this reason, it was decided not to implement
semantic error detection in \mypddl yet.


Another major drawback of \pddlstudio and \pddlmode for Emacs
especially, is that they are apparently not updated regularly to work
with the most recent \pddl versions. \pddlstudio's parser is only able
to parse \pddl 1.2, one of the first \pddl versions. As of writing
this thesis, the latest \pddl version is 3.1. It must be mentioned
that \pddl has evolved since \textsc{pddl} 1.2 and was extended in
\pddl 2.1 to include durative actions to model time dependent
behaviors, numeric fluents to model non-binary changes of the world
state, and plan-metrics to customize the evaluation of plans
\cite{fox2003pddl2}. \pddlmode for Emacs only works with \pddl
versions up to 2.2, which introduced derived predicates and timed
initial predicates \cite{edelkamp2004pddl2}, but does not recognize
later features like object-fluents, so that the range of functions,
specified in the domain file, cannot include object-types in addition
to numbers. \itsimple on the other hand is more regularly maintained
and \itsimple4.0 is in beta status since 2012 \cite{itsimpleonline}.
The release will be the first \itsimple version intended to also
support the creation of \pddl documents from scratch, meaning that the
text editor plays a much larger role in this version compared to
previous ones.

Finally, one of the most important features of any software is the
possibility of extending and customizing it
\cite{hui2003requirements}. Different programmers need to work with
many different tools and need them to have a similar look and feel;
they have different use cases and thus need different plug-ins and
extensions to meet their needs, or they may simply have different
preferences. \pddlstudio falls short of satisfying this requirement as
the customization features (without editing the source code) are
limited to the choice of font style and color of highlighted \pddl
expressions. Furthermore, \pddlstudio is written as standalone
program, meaning that there are no \pddl independent extensions. The
same holds true for \itsimple which is also not customizable without
editing the source code. Being an Emacs mode and Emacs being an
established text editor, \pddlmode is highly and easily customizable
and extensible.

This is the other major reason why it was decided that \mypddl should
be integrated into a existing, extensible, and customizable text
editor. These requirements are intended to be met by Sublime Text, a
text editor that sports such features as customizable key bindings,
display of line numbers and multi-line selection. In addition, there
is a broad range of extensions for Sublime Text, so that features like
revision control via Git, file management with a sidebar, color
highlighting of matching brackets or comparing and merging files can
be added. Furthermore, Sublime Text supports the majority of common
programming and markup languages, in order for users to use the same
tool and settings for programming and \pddl specifications.

\mypddl is designed as a package for Sublime Text and provides
sophisticated syntax highlighting, code snippets, syntactical error
detection and type diagram visualization. Additionally, it allows for
the automation of modeling tasks due to a Clojure interface that
supports the conversion of \textsc{pddl} code into Clojure code and
vice versa. Therefore, the \mypddl shell supports both the initial
design process of creating domains (with code snippets, syntax
highlighting and the Clojure interface), and the later step of
checking the validity of existing domains and problems with the type
diagram generator. Lastly, since it is increasingly important that
several people work on one project together, the visualization
capabilities of \mypddl are meant to help users to understand each
other's code faster and thus be able to work with it more efficiently.

[fn:2] Features such as automatic indentation, selection of tab size,
defining custom key shortcuts, customizing the general look and feel,
displaying line numbers, and bracket matching.


* Knowledge Engineering Tools for Artificial Intelligence Planning
<<ch:tools>>
  
** Statement of Problem

The erroneous domain in Chapter [[ch:introduction]] and the /Hacker World/
and /Gary's Huge Problem/, presented in Chapter [[ch:basics]], already
indicated that writing and maintaining \pddl files can be
time-consuming and cumbersome
\cite{li2012translating,zhuo2010learning}. But not only the modeling
effort can be quite huge in contrast to the length of the generated
output. Due to the amount of information that has to be integrated for
specifying \pddl domains, files can get confusing and error-prone.
\pddl's modeling capacities have been extended over the last years
(source) and it is likely that it will be used for even more complex,
realistic domains that are designed by a team of experts instead of a
single person \cite{shah2013knowledge}. For these purposes, tools that
support knowledge engineers at different design steps seems to be
reasonable. The following sections will present \mypddl, an
extensible, modular system, designed for supporting knowledge
engineers in the process of writing, analyzing and expanding \pddl
files and thereby promote the collaboration between knowledge
engineers and the use of \pddl in real-world applications. It consists
of the following, integral parts:

- my\textsc{pddl}-new :: Create a \pddl project
     folder structure with \pddl domain and problem skeletons.
- my\textsc{pddl}-gen :: A type diagram generator for
     analyzing the structure of \pddl type hierarchies.
- my\textsc{pddl}-loc :: Automated distance calculation for
     \pddl locations, specified in a problem file. 
- my\textsc{pddl}-syn :: A context-aware syntax highlighting feature.
- my\textsc{pddl}-snp :: Code snippets (templates), which can be
     inserted in \pddl files.
- my\textsc{pddl}-sub :: A integrated development environment for the
     afore mentioned tools to be used in Sublime Text.

A general interface between \pddl and Clojure allows for
bypassing \pddl's limited mathematical modeling capacity and
serves as a basis for /new/, /gen/ and /loc/. As stated before,
\mypddl is focused on customizability and extensibility,
ranging from the editor-dependent choice of key bindings and themes to
adding a new module based on a general interface between \pddl
and Clojure (TODO: write more beautiful).

** General Interface between PDDL and Clojure

In accordance with programming languages, you might want to automate
tasks, do sophisticated mathematics on parts of a planning
specification or . However, \pddl's calculating capabilities are
limited \cite{parkinson2012increasing}. While these features are
currently not supported by \pddl itself, pre-processing \pddl files
and thereby integrate the information into the file seems to be a
reasonable workaround. At this end, an interface with a programming
language seems feasible. It can thus partly automate the modeling
process as well as reduce the modeling time (see [[subsec:loc]] the distance
calculator \mypddl-loc). As \pddl is used to create more and more
complex domains \cite{goldman2012type,guerin2012academic}.

In this section, a general approach for generating \pddl
constructs, but also for reading in domain and problem files,
handling, using and modifying the input, and generating \pddl
files as output, will be presented.

While it seems to be reasonable to further extend \pddl's
modeling capability to at planning time instead of modeling time, a
modeling support tool as pre-processor is appropriate in any case
(http://orff.uc3m.es/bitstream/handle/10016/14914/proceedings-WS-IPC2012.pdf?sequence=1#page=47)


As \pddl's syntax is inspired by Lisp \parencite[64]{fox2003pddl2},
using a Lisp dialect for the interface seems reasonable. This way,
file input and output methods can use s-expressions (i.e.
parenthesized lists) instead of regular expressions so that parts of
\pddl files can be accessed in a convenient way, and amongst other,
automated code layout and indentation. This thesis uses Clojure
\parencite{hickey2008clojure}, a modern Lisp dialect that
runs on the Java Virtual Machine (JVM) \cite{lindholm2011virtual}.

The interface is built on two methods:
- read-construct(keyword,file) ::  Allows for the
     extraction of a \pddl construct, specified by its name.
- add-construct(file,position,part) :: Provides a means for adding
     \pddl constructs to a specified position, indicated by a
     keyword.

The /read-construct/ method thereby makes use of an safe reader that
avoids that read-in constructs can be executed.

Once a part is extracted and represented in Clojure, the processing
possibilities are manifold and the full capacities of Clojure can be
used.

The interface is provided as a library, so that its methods can be
included in any Clojure file.


** Create PDDL Projects (myPDDL-new)
In many cases, creating \pddl domains is kind of an ad-hoc process
\cite{shah2013exploring}. However, prior to each implementation of a
\pddl task specification stands the creation of a new /project/,
consisting of at least one domain and a belonging problem file. As
several team members may be working on this project, "Have a place for
every thing, and keep every thing in its proper place" would be
desirable. To this end, a standardized project folder structure could
facilitate, collaboration, maintaining and and keep consistency over
projects ... and the organization.

/my\textsc{pddl}-new/ creates \pddl project folders, on the
basis of a project name (Figure \ref{fig:mypddl-new-project-folder}).


#+NAME: mypddl-new-project-folder-without
#+CAPTION: The project folder structure
#+CAPTION: created by myPDDL-new. The project-name is chosen by the user 
#+CAPTION: and used for the name of the created domain.
#+BEGIN_FIGURE
  \dirtree{%
  .1 project-name.
  .2 dot.
  .2 diagrams.
  .2 domains.
  .2 problems.
  .3 p01.pddl.
  .2 solutions.
  .2 domain.pddl.
  .2 README.md.
  }
#+END_FIGURE


#+NAME: mypddl-new-project-folder
#+BEGIN_LATEX
\begin{figure}[] 
  \dirtree{%
  .1 project-name.
  .2 dot.
  .2 diagrams.
  .2 domains.
  .2 problems.
  .3 p01.pddl.
  .2 solutions.
  .2 domain.pddl.
  .2 README.md.
  }
\caption[]{\label{fig:mypddl-new-project-folder}The project folder structure created by myPDDL-new. The project-name is chosen by the user and used for the name of the created domain.}
\end{figure}
#+END_LATEX

In this project folder, the domain file =domain.pddl= and the problem
file =p01.pddl= (in the folder =problems=) are filled with basic \pddl
skeletons (TODO: remove this sentence or add functionality or even
better: specify a template, which can be added!). The templates for
the skeletons are located in the myPDDL folder and be customized to
your need by editing and saving the template. \\
The =domains=, =dot= and =diagrams= folders are created for the use
with /my\textsc{pddl}-gen/, which will save its generated output to
these folders and thereby allows for a basic version control system
(see [[subsec:gen ]]Type Diagram Generator (myPDDL-gen)). \\
As one domain file can have multiple problem files, the =problems=
folder is designed for the collection of all associated problem files.
\\ Recognizing, that most knowledge engineers do not write any
documentation related to the specified planning task
(\cite{shah2013knowledge}), =README.md= is a Markdown (a plain text
formatting syntax) file, which is, amongst others, intended for
information about the author(s) of the project, contact information,
informal domain and problem specifications, and licensing information.
Markdown files are converted to HTML by various hosting services that
use the Git system. This way, this file can be used as an quick
overview for \pddl projects, located at hosting service.

This approach should support an structured and organized design
process. The choice of a folder structure (instead of a project file)
has the advantage of being readable and customizable independently of
the editor. So the need for team work \cite{shah2013knowledge} is
tackled by using a structured project folder where and changes can be
seen in the view of the diagram. This directory organization is
intended to contain a single or just a few domain files in one
project, stored in the project root directory, while problem files are
stores in the subfolder problems.


** Syntax Highlighting (myPDDL-syn)  

 *** Statement of Problem
 <<sec:syntax>>

Writing and maintaining \pddl files is an ongoing process. Continually
growing, \pddl files can span several pages and contain hundreds or
thousands of lines of code. In order to recognize parts of the file
quickly and detect errors at a glance, distinguishing code parts by
color seems to be a reasonable way for aiding the designer.

\mypddl-syn distinguishes comments, variables, subtypes, types,
keywords, inbuilt-functions and highlights them in different colors by
a sophisticated pattern matching heuristic that can both recognize the
start and the end of a larger code block (like =(:predicates ...)=).
This way, knowledge engineers can skim through the code and ignore
parts of the code.

While syntax highlighting can be helpful in get along inside code and
keep an overview, it could be especially powerful, if syntax errors
could get quickly detected. Missing brackets or expression at the
wrong position are possible sources of error. Knowledge Engineers can
ignore larger parts of the code (e.g. comments) that are visually
distinct.

Figure XYZ displays an extract of the /Coffee/ world, a domain used in
the user study for the evaluation of this tool.  

#+CAPTION: The deliberately erroneous /Coffee/ world without (a) and with (b) syntax highlighting, using the color scheme /Monokai/.
#+CAPTION: All non-highlighted (white) constructs either contain errors or are specified in the wrong block.
#+BEGIN_LaTeX
\begin{figure}
\begin{subfigure}[b]{.5\linewidth}
\centering\large A
\caption{A subfigure}\label{fig:1a}
\end{subfigure}%
\begin{subfigure}[b]{.5\linewidth}
\centering\large B
\caption{Another subfigure}\label{fig:1b}
\end{subfigure}
\caption{A figure}\label{fig:1}
\end{figure}
#+END_LaTeX

By using the inbuilt Sublime Text color scheme /Monokai/, almost all
proper \pddl constructs get highlighted in colors according to
their meaning. Constructs written in white usually contain errors, are
written at the wrong place or are not specified by \pddl3.1.
This way correct constructs and errors are visually distinct.
Highlighted code could nevertheless contain semantic errors. This was
tested by means of ...

Longer files can get quickly
confusing. Therefore, it is convenient to have a tool that supports
editing these files. The syntax highlighting feature displays code in
different colors according to the category of terms. In order to
facilitate editing PDDL files, a syntax highlighting plug-in for the
Sublime Text editor \cite{sublimetext2,sublimetext3} is proposed.


For this reason, the implemented highlighter makes use of scopes, so
that identify code parts by begin and end markers.


*** Implementation and Customization

For the ease of creation, the \pddl syntax highlighter is
implemented by the use of the ST plug-in \textcite{aaapackagedev}. So,
the definitions can be written in YAML in converted to Plist
\textsc{xml} later on. \textcite{aaapackagedev} is a ST plugin, that
helps to create, amongst others, ST packages, syntax definitions and
'snippets' (re-usable code).

By means of Oniguruma regular expressions \parencite{kosako}, scopes
are defined, that determine the meaning of the \pddl code
block. ST themes highlight different parts of the code by the use of
scopes. Scopes are defined by the use of regular expressions (regexes)
in a tm-Language file. The scope naming conventions mentioned in the
\citetitle{textmate} are applied here. By the means of the name, the
colors are assigned according to the current used ST theme. That means
that colors are not assigned per se, but dependently on the current
scheme. Through that, experienced users can use their default theme
and all can easily change the colors by changing the scheme. Different
ST themes display different colors (not all themes support all naming
conventions).

The syntax highlighting is intended for \pddl 3.1, but is backward
compatible to previous versions. It's based on the Backus-Naur Form
(BNF) descriptions, formulated in
\textcite{kovacs2011bnf,fox2003pddl2,mcdermott1998pddl}.

The pattern matching heuristic that is implemented by the use of
regular expressions is used for assigning scopes to the parts of the
file. As a result of \pddl's Lisp-derived syntax,
\pddl uses the s-expression format for representing
information (SOURCE!). So, the semantic of a larger \pddl part
(sexpr) can be recognized by a opening parenthesis, followed by
\pddl keyword and finally matched closing parentheses
(potentially containing further sexpr). These scopes allow for a
fragmentation of the \pddl files, so that constructs are only
highlighted, if they appear in the right section.

The YAML-tmlanguage file is organized into repositories, so that
expressions can be re-used in different scopes. This organization also
allows for a customization of the syntax highlighter. The default 

The first part of the \pddl.YAML-tmlanguage
describes the parts of the \pddl task that should be highlighted. By
removing (or commenting) include statements, the syntax highlighter is
adjustable the user's need.


#+NAME: Screenshot in Sublime Text 3
#+CAPTION: Coffee domain with and without syntax highlighting
[[/home/pold/Documents/BA/org-ba/thesis/img/coffee_errors_img.png]]
[[/home/pold/Documents/BA/org-ba/thesis/img/coffee_errors_no.pngp]]


*** Usage and Customization
**** Volker Workflow
Gary creates a new \pddl project using the command line, to this end he
types

\includegraphics{sus.eps}


To get an overview over the world structure, Gary doodles a quick type
diagram with the freely available graph editor and layout program yEd
(yFiles software, Tübingen, Germany) that represents the world and its
structure. Of course, he could also do this by pen and paper or using
any other graph editor.

[./gary_sketch.svg ]

He then opens this domain file in the Sublime Text 2 editor

#+BEGIN_SRC bash
$ sublime gary-hacker-world.pddl
#+END_SRC

and starts to model his world. To this end, he uses the code snippets
=domain= for creating the domain skeleton, navigates inside the domain
file with \Tab, creates new type definitions with the snippets =t2=
and =t3=. After completing his first draft, he presses \keystroke{f8},
for saving his file and displaying the \pddl type diagram and
sees the following diagram:

[.././hacker-world/diagrams/png-diagram3.png ]

He recognizes, that he forgot to model that system software can be
sub-divided into drivers and operating systems. Therefore he closes
the diagram and adds the missing type declaration. He continues to
write the \pddl domain and adds the required predicates with
=p1= and =p2=, for example he types

The syntax highlighter shows Gary, if the uses incorrect \pddl syntax
or if the forgets to close a parenthesis, as then parts don't get
highlighted. 

A final check show that everything is as expected:

[.././hacker-world/diagrams/png-diagram3.png]

Gary knows, that the type diagram generator uses the Clojure
interface. So, adding =#_= just before the predicates s-expression
(that means =#_(:predicates ...)= excludes the predicates from the
type diagram, as this is the Clojure notation for commenting out
s-expressions (and more convenient than commenting every single line).
However, the =#_= construct is /not/ correct \pddl, so Gary generates
the diagram without the predicates, checks and sees that everything is
fine, removes the =#_=, saves and closes the file. 

The final version in the ST editor now looks like this:
[./domain2.pdf ]

In the command line, he now opens the \pddl problem file p01.pddl
#+BEGIN_SRC bash
$ sublime p01.pddl
#+END_SRC
and adds the problem skeleton by typing =problem= and pressing \Tab.

The generated files (=dot-diagram[0-2].dot=, =png-diagram[0-2].png=,
=garys-hacker-world[0-2].pddl=) are the revision control versions,
generated each time the Clojure script is invoked (by pressing \keystrokes{F8}).

It can probably be seen, that this rather short description of the
world and in problem results in rather extensive \pddl files.


** Code Snippets (myPDDL-snp/)

Consider again the basic skeleton of an action:

#+BEGIN_SRC text
(:action action-name
	:parameters (?x - object)
	:precondition (and (pred-1))
	:effect (and ))
#+END_SRC

Almost all \pddl actions consist of these same sections.
Writing and extending \text{pddl} files, knowledge engineers are
supposed to use the same constructs again and again. This is there
code snippets come in. To facilitate and fasten the implementation of
standard constructs, my-PDDL-snp provides code snippets. These
snippets are templates for often used \text{pddl} constructs, like
domain and problem definitions, predicates and actions. They can be
inserted by typing a trigger keyword. Typing =action= and pressing the
\tab key, would exactly insert the action specified in Listing xyz.

Having inserted the skeleton, it still has to be filled in. That means
a means for easily navigating inside the code snippet would become
handy. For this purpose, the blanks can be filled by pressing \tab on
the keyboard and thereby navigating inside the snippet, so that the
cursor will first mark the action-name .q inserted content contains fields
with placeholders, that can be accessed and filled in consecutively.
\pddl constructs with a specified arity can be inserted by
adding the arity number to the trigger keyword (p2 would insert the
binary predicate template =(pred-name ?x - object ?y - object)=.

#+BEGIN_LaTeX
\begin{figure}[h]
\keystroke{p}\keystroke{2}\Tab\keystroke{h}\keystroke{a}\keystroke{s}\Tab\keystroke{s}\Tab\keystroke{s}\Tab\keystroke{p}\Tab\keystroke{p}\Tab
\caption[Example for the use of snippets]{\label{fig:snippet-example} Example for the use of snippets. =p2= creates a binary predicate template that can filled in.}
\end{figure}
#+END_LaTeX

Every snippet is stored in a separate file, located in the =PDDL/=
folder. New snippets can be added and existing snippets can be
customized there (change the template or change the trigger keyword).


** Distance Calculation for PDDL Locations (myPDDL-loc)
<<subsec:loc>>

/Hacker World/ in Chapter 2, defines the predicate =(location ?f -
furniture ?x ?y - number)=. A possible extension to this domain would
be an action that is only applicable, if a person is within a certain
distance to an object. In order to determine this distance, it could
be desirable to use the Euclidean distance that includes the square
root function (=\sqrt=). An Euclidean distance function that uses the
square root would be convenient for distance modeling and measurement.
However, \pddl 3.1 supports only four arithmetic operators (+,
-, /, *). However, \pddl does only support basic arithmetic
operations (=+=, =-=, =/=, =*=). These operators can be used in
preconditions, effects (normal/continuous/conditional) and durations.
\textcite{parkinson2012increasing} describe a workaround for this
drawback. By declaring an action `calculate-sqrt', they bypass the
lack of this function and rather write their own action that makes use
of the Babylonian root method. While the square root could be
approximately determined using the Babylonian method, requiring many
iterations, this method would most likely have an adverse effect on
plan generation \cite{parkinson2012increasing}.

The PDDL/Clojure interface and reads a problem file and extracts all
locations, defined in the =:init= part. In Clojure, the Euclidean
distances between all locations are calculated and then written back
to an extended problem file.

The calculator works on any arity of the specified predicate, so that
locations could be specified one, two and three dimensionally and even
used in higher dimensions.

However, this approach has certainly a major drawback, apart from the
time required to calculate (non-used) distances. If the number of
locations is $n$, the number of calculated distances is $n^2$, as
every location has a distance to every other. The calculated distances
have to be stored in the \pddl problem file, so that possibly
a lot of space is used. This is why it seems to be reasonable to
extend textsc{pddl}'s mathematical operations. In accordance with
\textcite{parkinson2012increasing}, extending  a possibility would be a
\textsc{pddl }
A possibility would be to declare a requirement =:math=
that specifies further mathematical operations and to extend
\pddl in future versions.

#+CAPTION: Problem file before using myPDDL
#+BEGIN_SRC text
  ...
  (:init (location home-gary 7 3)
         (location home-gisela 10 5)) 
  ...
#+END_SRC

#+CAPTION: After
#+BEGIN_SRC text
 (:init
  (location home-gary 7 3)
  (location home-gisela 10 5)
  (distance home-gary home-gary 0.0)
  (distance home-gary home-gisela 3.6056)
  (distance home-gisela home-gary 3.6056)
  (distance home-gisela home-gisela 0.0))
#+END_SRC

** Type Diagram Generator (myPDDL-gen)
<<subsec:gen>>

As stated by the adage "A picture is worth a thousand words" graphical
representations can simplify to textual representations. In a computer
science, the graphical visualization of textual information should
simplify the communication and collaboration between developers and
help to quickly grasp the connection of hierarchical structured items
\cite{storey2005use}.

Object types play a major role in typed \pddl domains: they
constrain the types of arguments to predicates and determine the types
of parameters used in actions. In order to understand, use and extend
available domains, a crucial part is grasping involved types,
understand their hierarchy, and identify the constructs that make use
of them. However, this can be difficult by just reading \pddl
the textual representation of the hierarchy, so a diagram that
displays this hierarchy could be helpful.

Creating this diagram manually each time a change is made can be
unhandy, takes time and can be a source of errors. To this way, an
automated graphical representation, based on a \pddl file
could save time and energy.

\mypddl-gen serves this purpose and generates and displays diagrams by
means of domain files. Figure xyz shows the automatically generated
diagram from the /Hacker World/ in Chapter 2. In the diagram, types
are represented with boxes, whereby every box consists of two parts:

- The header displays the name of the type.
- The lower part displays all predicates that use the corresponding
  type at least once as parameter. The predicates are written in the
  same way, as they appear in the \pddl code.

Generalization relationships ("is a", for example "a laptop /is a/
computer") are expressed by arrows from the subtype (here: /laptop/)
to the super type, where the arrow head aims at the super type (here:
/computer/). This relationship expresses, that every subtype is also
an instance of the illustrated super type.

#+CAPTION: The type diagram that was generated from the
#+CAPTION: /Hacker World/ using myPDDL-gen.
[[/home/pold/Documents/BA/org-ba/hacker-world/dot/gary-pdf.pdf]]

In order to create the diagram, /gen/ makes use of the PDDl/Clojure
interface that extracts the =(:types ...)= block. Then, using regular
expressions, the extracted types get split in super types and
associated subtypes and stored in a Clojure hash-map.

Subsequently, the diagram is generated using dot from the Graphviz
package \cite{ellson2002graphviz}, a collection of programs for
drawing graphs. dot is a scriptable, graphing tool, that is able to
generate hierarchical drawings of directed graphs in a variety of
output formats (e.g. \textsc{png}, \textsc{pdf}, \textsc{svg}). The
input to dot are text files, written in the \textsc{dot} language.

Based on the Clojure representation, the description of a directed
graph (=digraph=) in the \textsc{dot} language is created and saved in
the folder =dot/= that is located in the same folder as the
\pddl domain file. The \textsc{dot} file is then passed to dot
and a \textsc{png} diagram is created and saved in the folder
=diagrams/=. Additionally, the diagram will be immediately opened and
displayed in a window. In addition, a copy of the domain file is
stored in the folder =domains/=. Every time /my\pddl-gen/ is
invoked, these steps are executed and the saved file names are
extended by a ascending revision number. Thus, one cannot only
identify associated \pddl, \textsc{dot} and \textsc{png}
files, but also use this feature for basic revision control. Figure
xyz displays the folder structure after invoking /dia/ twice on the
/Hacker World/. This way, the type hierarchy and predicate structure
of a previous version of a domain file can be identified by the
correspondent type diagram (both files have matching revision
numbers), and one can revert to a previous revision, stored in the
=domains/= folder. All folders are created if necessary.

#+NAME: mypddl-gen-folder-structure
#+BEGIN_LATEX
\begin{figure}[] 
\dirtree{%
.1 hacker-world.pddl.
.2 dot.
.3 dot-diagram0.dot.
.3 dot-diagram1.dot.
.2 diagrams.
.3 png-diagram0.png.
.3 png-diagram1.png.
.2 domains.
.3 hacker-world0.pddl.
.3 hacker-world1.pddl.
}
\caption[\textit{my\pddl-gen} folder structure]{\label{fig:mypddl-new-project-folder} Folder structure after two invocations of textit{my\pddl-gen}. Files and folders are automatically created and extended by a revision number (=0=,=1=) each time /gen/ is used.}
\end{figure}
#+END_LATEX


** Integrated Design Environment (myPDDL-sub) 

The so far presented tools provide a command-line interface for
interacting with the user. This offers a high flexibility, the
possible automation of jobs by using scripts, and the possibilty for a
integration in different software. However, the user has to be
familiar with the underlying syntax, in order to use the full spectrum
of available functions. By using ST as editor, language independent ST
features are supported, like auto completion of words already used in
this file, code folding and column selection, described in the Sublime
Text 2 Documentation. Sublime Text is used to combine the so far
presented command-line tools, as well as the syntax highlighter and
the code snippets into an IDE. While /snp/ and /syn/ are devised
explicitly for ST and therefore integrated from the outset, the other
tools (/new/, /gen/, /loc/) can be used independently of ST utilizing
the command-line interface and any \pddl file. To provide an
IDE for using \mypddl, /-sub/ integrates new, gen and loc, aiming at a
a user-friendly execution and use of the system.

This way a menu-driven interface is provided and 
The three tools can be invoked using the ST command palette
(\keys{\ctrl+\shift+P}), and then choosing one of the PDDL menu entries:

- /PDDL: Create Project/ for myPDDL-new :: /PDDL: Create Project/
     requires the user to specify a project name in the then displayed
     input panel.
- /PDDL: Calculate Distances/ :: for \mypddl-loc Saves and 
- /PDDL: Display Diagram/ :: for \mypddl-dia


\mypddl can be installed automatically via Sublime Text
Package Control or by placing the files of \mypddl [fn:8] in the packages
folder of Sublime Text [fn:7]. Following, the features can be
activated by changing Sublime Text's syntax to \pddl
(=View->Syntax->\pddl=).

[fn:7] Further information about Sublime Text packages can be found at
http://www.sublimetext.com/docs/3/packages.html.

[fn:8] The files can be downloaded from https://github.com/Pold87/ba-thesis/.


* Evaluation
<<ch:evaluation>>

TODO: Spannender Einleitungssatz To evaluate a software means to
assess its quality. Even though there exists an international standard
(ISO/IEC 25010) to evaluate software, most of the eight
characteristics that serve as quality criteria are irrelevant for this
project. More appropriate criteria are supplied by
\textcite{shah2013knowledge} who evaluate different knowledge engineering
tools in planning, including, among others, \itsimple. All in all,
they identified seven criteria, the lead questions of which can be
found in table \ref{tab:criteria} [[tab:criteria]].

#+CAPTION: The seven design criteria that were identified by \textcite{shah2013knowledge}
#+NAME: tab:criteria
| Criteria       | Description                                                |
|----------------+------------------------------------------------------------|
| Operationality | How efficient are models produced?                         |
|                | Is the method able to improve the performances of planners |
|                | on generated models ans problems?                          |
| Collaboration  | Does the method/tool help in team efforts?                 |
|                | Is the method/tool suitable for being exploited in teams   |
|                | or is it focused on supporting the work of a single user?  |
| Maintenance    | How easy is it to come back and change a model?            |
|                | Is there any type of documentation that is automatically   |
|                | generated?                                                 |
|                | Does the tool induce users to produce documentation?       |
| Experience     | Is the method/tool indicated for inexperienced users?      |
|                | Do users need to have good knowledge of PDDL?              |
|                | Is it able to support users and to hide low level details? |
| Efficiency     | How quickly are acceptable models produced?                |
| Debugging      | Does the method/tool support debugging?                    |
|                | Does it down on the time needed to debug?                  |
|                | Is there any mechanism for promoting the overall quality   |
|                | of the model?                                              |
| Support        | Are there manuals available for using the method/tools?    |
|                | Is it easy to receive support?                             |
|                | Is there an active community using the tool?               |


+----------------+------------------------------------------------------------+
| Criteria       | Description                                                |
+----------------+------------------------------------------------------------+
| Operationality | How efficient are models produced?                         |
+----------------+------------------------------------------------------------+
|                | Is the method able to improve the performances of planners |
+----------------+------------------------------------------------------------+
|                | on generated models ans problems?                          |
+----------------+------------------------------------------------------------+
| Collaboration  | Does the method/tool help in team efforts?                 |
+----------------+------------------------------------------------------------+
|                | Is the method/tool suitable for being exploited in teams   |
+----------------+------------------------------------------------------------+
|                | or is it focused on supporting the work of a single user?  |
+----------------+------------------------------------------------------------+
| Maintenance    | How easy is it to come back and change a model?            |
+----------------+------------------------------------------------------------+
|                | Is there any type of documentation that is automatically   |
+----------------+------------------------------------------------------------+
|                | generated?                                                 |
+----------------+------------------------------------------------------------+
|                | Does the tool induce users to produce documentation?       |
+----------------+------------------------------------------------------------+
| Experience     | Is the method/tool indicated for inexperienced users?      |
+----------------+------------------------------------------------------------+
|                | Do users need to have good knowledge of PDDL?              |
+----------------+------------------------------------------------------------+
|                | Is it able to support users and to hide low level details? |
+----------------+------------------------------------------------------------+
| Efficiency     | How quickly are acceptable models produced?                |
+----------------+------------------------------------------------------------+
| Debugging      | Does the method/tool support debugging?                    |
+----------------+------------------------------------------------------------+
|                | Does it down on the time needed to debug?                  |
+----------------+------------------------------------------------------------+
|                | Is there any mechanism for promoting the overall quality   |
+----------------+------------------------------------------------------------+
|                | of the model?                                              |
+----------------+------------------------------------------------------------+
| Support        | Are there manuals available for using the method/tools?    |
+----------------+------------------------------------------------------------+
|                | Is it easy to receive support?                             |
+----------------+------------------------------------------------------------+
|                | Is there an active community using the tool?               |
+----------------+------------------------------------------------------------+


#+BEGIN_LaTeX
% This LaTeX table template is generated by emacs 24.3.1
\begin{tabular}{ll}
\hline
Criteria & Description \\
\hline
Operationality & How efficient are models produced? \\
\hline
 & Is the method able to improve the performances of planners \\
\hline
 & on generated models ans problems? \\
\hline
Collaboration & Does the method/tool help in team efforts? \\
\hline
 & Is the method/tool suitable for being exploited in teams \\
\hline
 & or is it focused on supporting the work of a single user? \\
\hline
Maintenance & How easy is it to come back and change a model? \\
\hline
 & Is there any type of documentation that is automatically \\
\hline
 & generated? \\
\hline
 & Does the tool induce users to produce documentation? \\
\hline
Experience & Is the method/tool indicated for inexperienced users? \\
\hline
 & Do users need to have good knowledge of PDDL? \\
\hline
 & Is it able to support users and to hide low level details? \\
\hline
Efficiency & How quickly are acceptable models produced? \\
\hline
Debugging & Does the method/tool support debugging? \\
\hline
 & Does it down on the time needed to debug? \\
\hline
 & Is there any mechanism for promoting the overall quality \\
\hline
 & of the model? \\
\hline
Support & Are there manuals available for using the method/tools? \\
\hline
 & Is it easy to receive support? \\
\hline
 & Is there an active community using the tool? \\
\hline
\end{tabular}
#+END_LaTeX

The first question that defines operationality (”How efficient are
models produced?”) is equivalent to the criterion efficiency and the
second question was not of interest when developing myPDDL, since it
can be reduced to the question of whether planners perform well on
standard PDDL files. Therefore, it was decided to replace the
criterion operationality with functional suitability from the ISO/IEC
25010 standard. To assess the functional suitability and to illustrate
where myPDDL fits in with similar tools, it was considered appropriate
to compare it to the other three tools introduced and discussed in
chapter 3, namely PDDL-Studio, itSIMPLE, and PDDL mode for Emacs. Of
the remaining six criteria in table XX, collaboration, experience, and
debugging were tested with a user test. The other three criteria,
maintenance, efficiency, and support, will simply be discussed.

** Functional Suitability

To assess the functional suitability, it was decided to compare myPDDL
to the three tools already discussed in related work: PDDL-Studio,
itSIMPLE, and PDDL-mode for Emacs. This is to show its appropriateness
or “the degree to which the software product provides an appropriate
set of functions for specified tasks and user objectives“ (ISO 25010
6.1.1). Where does myPDDL fit in with existing tools for the same
purpose? When and for which tasks it is best suited? The major user
objective is identical for all four tools and can be summed up as the
desire to integrate human knowledge into a knowledge based system, in
particular to create domains and problems that can be fed to a
planner. All tools intend to support this process in general and the
various different stages of the process to different degrees. They do
this via different features. However, sometimes knowledge engineers
may only have to alter or develop already existing models further.
myPDDL aims to also assist in the objective to quickly understand
foreign code. Table XY is to illustrate how the four tools compare in
terms of features and how each of these features is helpful in the
knowledge engineering process.


** Design Goals
|                           | \pddlstudio          | \itsimple | \pddlmode | \mypddl    |
|---------------------------+----------------------+-----------+-----------+------------|
| latest supported version  | \pddl \textsc{1.2}   | \pddl 3.1 | \pddl 2.2 | pddl 3.1   |
| syntax highlighting       | Yes                  | Yes       | Yes       | Yes        |
| syntactic error detection | Yes                  | No        | No        | By Context |
| semantic error detection  | Yes                  | No        | No        | No         |
| code completion           | Yes                  | No        | Yes       | Yes        |
| code snippets             | No                   | Yes       | Yes       | Yes        |
| code folding              | Yes                  | No        | Yes       | Yes        |
| project management        | Yes                  | Yes       | No        | Yes        |
| visualization feature     | No                   | Yes       | No        | Yes        |
| planner integration       | Basic                | Yes       | No        | Yes?       |
| automatic indentation     | No                   | No        | Yes       | Yes        |
| customization features    | No                   | No        | extensive | extensive  |

** Empirical Study
A key challenge of creating a sophisticated syntax highlighter without
the availability of a lexical parser, is the use of regular
expressions for creating a preferably complete \pddl identification.
While this a not possible by the expressiveness of regexes, this
syntax highlighter tries to come as close as possible.

The consistency and capability to highlight every \pddl construct in a
color according to its meaning, were checked by 320 (syntax
error-free) \pddl files, consisting of 87 domain and 230 problem files
(list of files). In that, no inconsistencies nor non-highlighted words
could be found.

While syntax highlighting can improve the time and ability to get
along in code files, it is mainly intended to distinct language
structures and syntax errors. 


** User Study

The nightmare of any system development group is spending years and
vast amounts of money on developing a system and finding, upon its
release, that users cannot interact with it properly or do not see how
it can help them. When designing and implementing a system intended to
support humans, it is therefore of great importance to determine its
usability. The best method for doing so is by usability testing
(inviting users to thoroughly test the software by means of a series
of realistic tasks and asking their opinions). Therefore, two of the
most important myPDDL features, syntax highlighting and type diagram
generation, were tested in a small user study.

*** Participants
A total of eight participants (two female participants, Meanage=23,
SDage=2 (TODO: Update)) took part in this usability test. Small sample
sizes are sometimes criticized even in usability studies, because it
is hard to detect issues that only few people have. For example, the
number of people that are affected by hard-to-find information on
vegan food served on a flight or by hard-to-find information on
luggage constraints differs. Therefore, the latter will most likely be
uncovered with small sample sizes, while the former might not.
Reviewing the scientific discussion on this topic at this point is
beyond the scope of this project, but testing more than the common
five participants (Nielsen, J. Estimating the number of subjects
needed for a thinking aloud test. International Journal of
Human–Computer Studies 41, (1994), 385–397.9. Nielsen, J. and Molich,
R. HE of user interface. In CHI ’90 Conference Proceedings. ACM, 1990,
249-256. Virzi, R.A. Refining the test phase of usability evaluation:
How many subjects is enough? Human Factors 34, (1992), 457-468.) is in
line with more recent research (Faulkner, L. (2003). Beyond the
five-user assumption: Benefits of increased sample sizes in usability
testing. Behavior Research Methods, Instruments, & Computers, 35(3),
379-383.; Hwang, W., & Salvendy, G. (2010). Number of people required
for usability evaluation: the 10±2 rule. Communications of the
ACM, 53(5), 130-133.). Eight subjects was the minimum possible in this
study in order to fully control for possible sequence and learning
effects. Also, it was ensured that all participants were familiar with
at least one LISP dialect, so that no one would be confused by program
code written as parenthesized lists. None of the participants had
prior experience with planning in general or PDDL in particular.
Furthermore, none of them had used Sublime Text before.

*** Material 
It was decided to conduct the experiment at the home of the
experimenter to have a more welcoming and relaxing atmosphere than in
a university laboratory. A 30-minute interactive video tutorial for
planning and myPDDL was recorded to familiarize participants with the
topic. A preliminary questionnaire was designed to assess the prior
experience with planning and Sublime Text. The system usability scale
(QUELLE) was chosen as a post questionnaire to measure participants’
attitudes concerning the two tested tools. The participants completed
the actual tasks on a laptop computer (15.6 inch screen) with an
additional screen (15.1 inch) for displaying the type diagram and the
code side by side. The times that participants took to answer
questions were recorded with the web site online-stopwatch.chronme.com
as this allowed splitting the total time on task into smaller times
for subtasks. Furthermore, the recorded times could be downloaded
directly as a .csv file. To test the syntax highlighting (SH) and the
type diagram (TD) generator, two different task types were needed. As
a within subjects design was considered most suited (to control for
individual differences within such a small sample), it was necessary
to construct two tasks for each of these two types to compare the
effects of having the tools available. For these four tasks, domains
(matched in difficulty) and instructions were written. The two tasks
to test syntax highlighting presented the user with domains that were
54 lines in length (WORTLAENGE) and contained 17 errors each. Errors
were distributed evenly throughout the domains and were categorized
into different types (WHAT TYPES) and the occurrence frequencies of
these types were matched across domains as well, to ensure equal
difficulty for both domains. To test the type diagram generator, two
fictional (WHAT IS FICTIONAL IN THIS CASE) domains with equally
complex type hierarchies (approximately same (5/6 layers) depth,
approximately same number (20/21) of types) consisting of non-words
were designed. The domains were also matched in length and overall
complexity (same number (1) of actions, same number (4) of
preconditions in action, approximately same number (2/3) of effects in
action, approximately same number (5/6) of predicates with the same
arity distributions). All questionnaires and task descriptions can be
found in Appendix X. Lastly, participants were given pen and paper to
help them solve tasks if they saw a need for it.

*** Method
No earlier than 24 hours before the experiment was to take place,
participants received the web link to the tutorial and were thus given
the option to watch in their own time if they felt so inclined. This
method was chosen, because it was important that participants learn
and understand the contents and this could be hindered by the presence
of the experimenter or the testing situation, depending on the
subject’s personality. Upon their arrival, participants were handed a
consent form and the preliminary questionnaire. If they had already
watched the tutorial, they were asked if they had had any questions
concerning the tutorial and if they thought that they had understood
everything. If they had not yet watched it at home, they proceeded to
do so. After the tutorial, they were asked to complete the tasks in
the order specified in table XY in Appendix Y. Two factors were
varied: whether the participant had the tools available for the first
two tasks or for the second two tasks, and whether the participant
started with an SH task or a TD task. For the SH tasks, participants
were given six minutes (a reasonable time frame tested on two pilots)
to detect as many of the errors as possible. They were asked to record
each error in a table (pen and paper) with the line number and a short
comment and to immediately correct them in the code if they knew how
to, but not to dwell on the correction if they did not. For the TD
task, participants were asked to answer five questions concerning the
domains, all of which could be facilitated with the type diagram
generator, but some of which still required looking in the code.
Participants were told, that they should not feel pressured to answer
quickly, but to not waste time either. Also they were asked to say
their answer out loud, once they figured it out. They were not told
that the time it took them to come up with an answer was recorded,
since this knowledge could make them feel pressured and lead to more
false answers. Once the participants had completed all four tasks,
they were asked to evaluate the perceived usability of myPDDL using
the SUS.

*** Design


|   | *S* | *Order*          |                  |                  |                  |
|---+-----+------------------+------------------+------------------+------------------|
| / | >   |                  |                  |                  |                  |
|   | A   | /Planet Splisus/ | /Logistics/      | Store            | Coffee           |
|   | B   | Store            | Coffee           | /Planet Splisus/ | /Logistics/      |
|   | C   | Planet Splisus   | Logistics        | /Store/          | /Coffee/         |
|   | D   | /Store/          | /Coffee/         | Planet Splisus   | Logistics        |
|   | E   | /Logistics/      | /Planet Splisus/ | Coffee           | Store            |
|   | F   | Coffee           | Store            | /Logistics/      | /Planet Splisus/ |
|   | G   | Logistics        | Planet Splisus   | /Coffee/         | /Store/          |
|   | H   | /Coffee/         | /Store/          | Logistics        | Planet Splisus   |

/Italic/: Tools part

*** Procedure
At the earliest, 24 hours ahead testing date, participants received a
link [fn:1] to a 30-minute video tutorial and were asked to watch this video
before the test, if possible. This tutorial comprised a general
introduction to planning and a more specific introduction to
\pddl's domain syntax. In the video, participants were also
asked to fulfill tasks regarding \pddl and check their
answers with the provided solutions in the video.

At testing date, participants were asked to sign a consent form and to
take a seat in front of a Laptop with a 13" display and a connected
monitor with a 17" display. If they did not already watch the
\pddl tutorial the participants first were asked to watch the
tutorial then. After that, any open questions regarding \pddl
and the general testing procedure were clarified.

All participants were provided with a one page summary of PDDL domain
syntax (/cheat sheet/) that they could always refer to. Furthermore,
they were allowed to take any hand-written notes that they took during
the video tutorial. (and to rewatch the video tutorial at any time).

Participants were then tested, according to a assigned order of tasks.

The participants did not and that there will be a /tools/ part.
Immediately before the tools part, a three minute video introduction
to the functionality of the syntax highlighter (my\textsc{pddl}-syn)
and the usage of (my\textsc{pddl}-gen) was given. Directly after his,
participants were asked to work on the tools parts. so that they faced
the tools were not confronted with the tools before the actual test.

[fn:1] http://www.youtube.com/playlist?list=PL3CZzLUZuiIMWEfJxy-G6OxYVzUrvjwuV

*** Results

**** Syntax Highlighting Tasks
**** Type Diagram Tasks

Syntax Highlighting Tasks Type Diagram Tasks Diagram XY shows the
geometric mean of the task completion time (this excludes participants
that did not complete the task. i.e. gave an incorrect answer) for the
two domains, Planet Splisus and Store, with and without the type
diagram generator for each question. It is evident, that when having
the type diagram generator available, participants answer each
question faster. However, subjects’ time on question with the Planet
Splisus domain is on average 37 seconds faster with the TDG than
without it, while with the Store domain, this time difference only
accumulates to 18 seconds, indicating an ordinal interaction effect of
domain and tool availability. The ordinal interaction in this case
means that the beneficial effect of having tools available depends on
the domain at hand. Assuming that the domains and questions were
successfully matched in difficulty, this interaction effect may be due
to…

#+BEGIN_LaTeX
  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{found-errors-splitted.pdf}
\caption[]{\label{fig:planet-splisus}The Domain Planet Splisus.}
  \end{figure}
#+END_LaTeX

* Conclusion and Future Work
<<ch:conclusion>>

The PDDL/Clojure interface provides a basis for dynamic and
interactive planning scenarios. So, time-dependent knowledge could be
modeled by adding facts (learning) to and retracting facts (forget) from
facts a \pddl file.

Besides that, interactive planning 

Furthermore the interface can be used to extract knowledge, specified
in another formal language and create \pddl files from them.

Knowledge engineers can customize and extend Sublime Text  as
Although, \mypddl is concentrated on Sublime Text, users could transfer
the ideas to other text editors. 

The plug-in for the editor ST could be further extended to provide
features of common integrated developing environments (IDE). A build
script for providing input to a planner for auto-matching domain and
matching problem(s) (or problem and matching domain) in ST could be
convenient.

Detecting semantic errors besides syntactic errors \textcite[as
implemented in][for \textsc{pddl1.2}]{plch2012inspect} Studio could be
the next step to detecting errors fast and accurate. Possible semantic
errors could be undeclared variables or predicates in a domain
specification.

In the diagram, predicates are only added to the types that are
explicitly mentioned in the argument of the predicate. However, as
subtypes of types declared in the predicate arguments, can also be
used as argument to the predicate, this means, that all
specializations of a type can also be used for this predicate. This
can be seen in Figure xyz ...:For example, a the \pddl domain
file could declare =(hungry ?p - person)=, although men and women can
be hungry. 

Another alternative is to make use of an external helper and, instead
of calculating every entry of the distance matrix. the distance only
if needed, incorporate every possible combination of two locations.

Besides ICKEPS, as mentioned in the introduction, also the yearly
workshop Knowledge Engineering for Planning and Scheduling (KEPS) will
promote the research in planning and scheduling technology.
Potentially, the main effort of for implementing models in planning
will be shifted from the manual knowledge engineering to the automated
knowledge acquisition (KA). Perception systems, Nevertheless, a
engineer who double-checks the generated tasks will be irreplaceable.


\mypddl - Modular Auxiliary for the Planning Domain Definition
Language, has been designed to support knowledge engineers in modeling
planning tasks as well as in understanding, modifying, extending and
using existing planning domains.

\mypddl has been implemented as an interface between Clojure
and PDDL, where PDDL editing features are fulfilled in the text editor
Sublime Text. It is designed as an modular architecture, which is
extensible, customizable and easy usable system. myPDDL-gen can
visualize any PDDL domain, without making semantic assumptions and
n-ary predicates.

Implemented features comprise code editing features, namely syntax
highlighting and code snippets, a type diagram generator and a
distance calculator,

The user study shows some initial evidence that the syntax
highlighting feature (\textsc{myPddl-sub}) and the type diagram
generator(\textsc{myPDDL-gen}) can support knowledge engineers in the
design and analysis process, in particular in error detection and in
keeping track of the domain structure, the type hierarchy and grasping
predicates using these types.

A faster understanding of the domain structure could be beneficial for
the maintenance and application of existing domains and problems, and,
possibly for the communication between engineers. Finally, real world
usage of PDDL can be promoted so that the focus of artificial
intelligence planning can also be shifted towards the design of plans,
following the citation "Plans are worthless, but planning is
everything".


\printbibheading
\printbibliography[nottype=online,heading=subbibliography,title=Paper Sources]
\printbibliography[type=online,heading=subbibliography,title=Website
Sources]

* Appendix

This code can also be found on the enclosed CD, and on the Internet
page https://github.com/pold87/sublime-pddl (most recent
version).

The website http://pold87.github.io/sublime-pddl/ is the accompanying
website for this project.

#+BEGIN_SRC clojure
(ns org-ba.core
  (:gen-class :main true)
  (:require [clojure.tools.reader.edn :as edn]
            [clojure.java.io :as io]
            [clojure.pprint :as pprint]
            [dorothy.core :as doro]
            [rhizome.viz :as rhi]
            [clojure.math.numeric-tower :as math]
            [quil.core :as quil]
            [clojure.java.shell :as shell]
            [me.raynes.conch :as conch]
            [me.raynes.conch.low-level :as conch-sh]
            [fipp.printer :as p]
            [fipp.edn :refer (pprint) :rename {pprint fipp}]
            [me.raynes.fs :as fs])
  (:import [javax.swing JPanel JButton JFrame JLabel]
           [java.awt.image BufferedImage BufferedImageOp]
           [java.io File]))

(defn read-lispstyle-edn
  "Read one s-expression from a file"
  [filename]
  (with-open [rdr (java.io.PushbackReader. (clojure.java.io/reader filename))]
    (edn/read rdr)))

(defmacro write->file
  "Writes body to the given file name"
  [filename & body]
  `(do
     (with-open [w# (io/writer ~filename)]
     (binding [*out* w#]
       ~@body))
  (println "Written to file: " ~filename)))

(defn read-objs
  "Read \textsc{pddl} objects from a file and add type
  (e.g. 'table bed' -> (list table - furniture
                        bed - furniture))"
  [file object-type]
  (as-> (slurp file) objs
        (clojure.string/split objs #"\s")
        (map #(str % " - " object-type) objs)))



(defn create-pddl
  "Creates a \textsc{pddl} file from a list of objects and locations"
  [objs-file objs-type]
  (str
   "(define (domain domainName)

  (:requirements
     :durative-actions
     :equality
     :negative-preconditions
     :numeric-fluents
     :object-fluents
     :typing)

  (:types\n"
   (pprint/cl-format nil "~{~&~5@T~a~}" (read-objs objs-file objs-type))
   ")

  (:constants

  )

  (:predicates

  )

  (:functions

  )

  (:durative-action actionName
     :parameters (?x - <objectType>)
     :duration (= ?duration #duration)
     :condition (at start <effects>)
     :effect (at end <effects>))
)"
   ))

(defn split-up
  "Split a \textsc{pddl} type list (:types obj1.1 obj1.2 - objT1 obj2 - objT2 ...)
  into strings of subtypes and associated types,
  [[subytype1 subtype 2 ... - type][subtype1 subtype2 ...][type]"
  [coll]
  ;; Remove ':types' if it is present.
  (let [coll (if (= :types (first coll))
               (rest coll)
               coll)]
    ;; Capturing group 1 is type1.1 type1.2.
    ;; Capturing group 1 is type1.
    (re-seq #"((?:(?:\b[a-zA-Z](?:\w|-|_)+)\s+)+)-\s+(\b[a-zA-Z](?:\w|-|_)+)"
            (clojure.string/join " " coll))))


(defn types->hash-map-helper
  "Convert splitted type list (['<expr>' '<subtype1.1> <subtype1.2> ...' '<type1>']
  to a hash-map {'<type1>': ['<subtype1.1>' '<subtype1.2>' ...], '<type2>': ...}"
  [coll]
  (reduce (fn [h-map [_ objs obj-type]]
            (let [key-obj-type (keyword obj-type)
                  existing-vals (key-obj-type h-map)]
              (assoc h-map
                key-obj-type
                (concat existing-vals
                        (clojure.string/split objs #"\s")))))
          {}
          coll))

(defn types->hash-map
  "Splits types and converts them into a hash-map"
  [pddl-types]
  (types->hash-map-helper (split-up pddl-types)))

(defn map-entry->TikZ-seq
  "Converts a hashmap entry (:key [val1 val2 ...])
to a TikZ string (key -- { val1, val2 })"
  [entry]
  (str
   (name (key entry))
   " -- "
   "{" (clojure.string/join ", " (val entry)) "}"))

(defn hash-map->TikZ-out
  "Converts complete \textsc{pddl} type hash-map to TikZ file"
  [h-map]
  (str
   "\\documentclass[tikz]{standalone}

\\usepackage[utf8]{inputenc}

\\usepackage{tikz}

\\usetikzlibrary{graphdrawing}
\\usetikzlibrary{graphs}
\\usegdlibrary{layered,trees}

\\begin{document}

\\begin{tikzpicture}

\\graph[layered layout, nodes={draw,circle,fill=blue!20,font=\\bfseries}]
{
  " (clojure.string/join ",\n  " (map map-entry->TikZ-seq h-map))
  "
};

\\end{tikzpicture}
\\end{document}"))

(defn types-map-entry->dot-language
  "Converts one hash-map entry
to the dot language"
  [entry]
  (str
   "\"" (name (key entry)) "\""
   " -> "
   "{" (clojure.string/join " " (map #(str "\"" % "\"")  (val entry))) "}"))


(defn types-hash-map->dot-language
  "Converts a \textsc{pddl} types hash-map
to the dot language notation"
  [pddl-types-map]
  (clojure.string/join "\n" (map types-map-entry->dot-language pddl-types-map)))

;;; Read \textsc{pddl} predicates and generate UML 'type' diagram
(defn get-types-in-predicate
  "Takes a \textsc{pddl} predicate,
  e.g. '(at ?x - location ?y - object)
  and returns the involved types, e.g.
  '(location object)"
  [pddl-pred]
  (remove
   (fn [s]
     (let [first-char (first (name s))]
       (or (= \- first-char)
           (= \? first-char)))) (rest pddl-pred)))

(defn pddl-pred->hash-map-long
  "Takes a \textsc{pddl} predicate, e.g.
  '(at ?x - location ?y - object) and returns a
  hash-map, that assigns the involved types
  to this predicate, e.g.
  {location [(at ?x - location ?y - object)],
   object [(at ?x - location ?y - object)]}"
  [pddl-pred]
  (reduce (fn [h-map pddl-type]
            (assoc h-map
              pddl-type
              (list pddl-pred)))
          {}
          (get-types-in-predicate pddl-pred)))


(pddl-pred->hash-map-long '(at ?x - location ?y - object))

;;; TODO: Create short version wiht prolog predicate style
;;; e.g. at/2
(defn all-pddl-preds->hash-map-long
  "Takes a list of \textsc{pddl} predicates and
  returns a hash-map of types and the
  assigned predicate"
  [pddl-preds]
  (let [pddl-preds (if (= :predicates (first pddl-preds))
                     (rest pddl-preds)
                     pddl-preds)]
    (apply merge-with concat
           (map pddl-pred->hash-map-long pddl-preds))))

(defn hash-map->dot
  "Converts a hash-map to
  dot language for creating
  UML diagrams"
  [h-map]  
  (map (fn [map-entry]
         (str (key map-entry)
              "[label = \"{"
              (key map-entry)
              "|"
              (clojure.string/join "\\l"  (val map-entry))
              "}\"]\n"))
       h-map))

(defn hash-map->dot-with-style
  "Adds dot template to
hash-map>dot"
  [h-map]
  (str
   "digraph hierarchy {
node[shape=record,style=filled,fillcolor=gray92]
edge[dir=back, arrowtail=empty]
\n"
   (clojure.string/join (hash-map->dot h-map))
   "}"))


(defn \textsc{pddl}->dot-with-style
  "Adds dot template to
hash-map>dot"
  [preds types]
  (str
   "digraph hierarchy {
node[shape=record,style=filled,fillcolor=gray92]
edge[dir=back, arrowtail=empty]
\n"

   (clojure.string/join (hash-map->dot (all-pddl-preds->hash-map-long preds)))
   (types-hash-map->dot-language (types->hash-map types))

   "}"))

;;; Example for Predicate:
(def predicates 
  '(:predicates (at ?x - location ?y - object)
                (have ?x - object) 
                (hot ?x - object)
                (on ?f - furniture ?o - object)))

;;; Example invocation:
(hash-map->dot-with-style (all-pddl-preds->hash-map-long predicates))


(defn get-\textsc{pddl}-construct
  "Takes a \textsc{pddl} keyword and a \textsc{pddl} domain/problem
file and returns all parts of the file that
belong to the \textsc{pddl} keyword."
  [pddl-keyword pddl-file]
  (filter #(and (seq? %)
                (= (keyword pddl-keyword)
                   (first %)))
          (read-lispstyle-edn pddl-file)))


                                        ; TODO: Throw error if length != 1
(defn get-\textsc{pddl}-predicates
  "Get all predicates in a \textsc{pddl} file"
  [pddl-file]
  (first (get-\textsc{pddl}-construct 'predicates pddl-file)))

(defn get-\textsc{pddl}-init
  "Get all predicates in a \textsc{pddl} file"
  [pddl-file]
  (first (get-\textsc{pddl}-construct 'init pddl-file)))


                                        ; TODO: Throw error if length != 1
(defn get-\textsc{pddl}-types
  "Get all types in a \textsc{pddl} file"
  [pddl-file]
  (first (get-\textsc{pddl}-construct 'types pddl-file)))

(defn \textsc{pddl}->dot
  "Takes a complete \textsc{pddl} file
and generates a UML type diagram"
  [pddl-file]
  (\textsc{pddl}->dot-with-style (get-\textsc{pddl}-predicates pddl-file)
                        (get-\textsc{pddl}-types pddl-file)))

(defn \textsc{pddl}->dot-commandline-input
  "Assumes that the \textsc{pddl} input is
a string and 'reads' this string"
  [pddl-file]
  (print "The type is " (type pddl-file))
  (\textsc{pddl}->dot (edn/read-string pddl-file)))


(defn \textsc{pddl}->dot-file-input
  "Reads \textsc{pddl} file"
  [pddl-file-name]
  (\textsc{pddl}->dot pddl-file-name))

;;;; math helper functions

(defn sqr
  "Square of a number"
  [x]
  (* x x))

(defn round-places [number decimals]
  "Round to decimal places"
  (let [factor (math/expt 10 decimals)]
    (double (/ (math/round (* factor number)) factor))))

(defn euclidean-squared-distance
  "Computes the Euclidean squared distance between two sequences"
  [a b]
  (reduce + (map (comp sqr -) a b)))

(defn euclidean-distance
  "Computes the Euclidean distance between two sequences"
  [a b]
  (math/sqrt (euclidean-squared-distance a b)))

;;;; End math helper functions

(defn calc-distance-good
  "Calculates the distance and writes
the calculated distances to a string
IS VERY GOOD !!!"
  [locations]
  (for [[ _ loc1 & xyz-1] locations
        [ _ loc2 & xyz-2] locations]
    ;; Euclidean distance rounded to 4 decimal places.
    (list 'distance loc1 loc2 (round-places (euclidean-distance xyz-1 xyz-2) 4))))

(defn get-specified-predicates-in-pddl-file
  "Extracts all locations in the predicates part
(by the specified name) in a \textsc{pddl} file"
  [pddl-file predicate-name]
  (filter #(and (seq? %)
                (= predicate-name (first %)))
          (get-\textsc{pddl}-predicates pddl-file)))

(defn get-specified-inits-in-pddl-file
  "Extracts all locations in the init part
(by the specified name) in a \textsc{pddl} problem"
  [pddl-file predicate-name]
  (filter #(and (seq? %)
                (= predicate-name (first %)))
          (get-\textsc{pddl}-init pddl-file)))

(defn calc-distance
  "Calculate distances of \textsc{pddl} objects"
  [locations]
  (for [[ _ loc1 & xyz-1] locations
        [ _ loc2 & xyz-2] locations]
    ;; Euclidean distance rounded to 4 decimal places.
    `(~'distance ~loc1 ~loc2
                 ~(euclidean-distance xyz-1 xyz-2))))

; LOOK UP: extended equality: 'hello = :hello

(defn add-part-to-\textsc{pddl}
  "Takes a \textsc{pddl} domain or problem
and add the specified part to the
specified position"
  [pddl-file position part]

  (map #(if (and (seq? %)
                 (= (keyword position) (first %)))
          (concat % part)
          %)
       (read-lispstyle-edn pddl-file)))

(defn find-new-file-name
  "Take a filename and determines, the new number
that has to be added to create a new file. E.g.
file1.img file2.img file3.img means that, file4.img
has to be created"
  [filename extension]
  (loop [n 0]
    (if-not (io/.exists (io/as-file
                         (str filename n extension)))
      (str filename n extension)
      (recur (inc n)))))


;;; Copied from https://www.refheap.com/9034
(defn exit-on-close [sketch]
  "Guarantees that Clojure script will be
exited after the JFrame is closed"
  (let [frame (-> sketch .getParent .getParent .getParent .getParent)]
    (.setDefaultCloseOperation frame javax.swing.JFrame/EXIT_ON_CLOSE)))


(defn extract-locations-from-file
  "Read a Blender \textsc{lisp} file and write object positions to out-file"
  [file-in file-out]
  (let [map-destructorer-local (fn [[_addgv _furniture object
                                      [_make-instance _object-detail
                                          _pose [_tfmps
                                                _type-name
                                                _type-num
                                                [_vector-3d x y z & more]
                                                & _more1]
                                       & _more2]]] (list "location" (name object) x y z))]
    (with-open [rdr (java.io.PushbackReader. (io/reader file-in))]
      (println
      (doall
          (map map-destructorer-local
               (filter #(and (seq? %) (= 'addgv (first %)))
                       (take-while #(not= % :end)
                                   (repeatedly  #(edn/read {:eof :end} rdr))))))))))


;; Main method
;; TODO: Command line options
(defn -main
  "Runs the input/output scripts"
  [& args]

  (cond
   ;; Create a new \textsc{pddl} project
   (= "new" (first args))
   (let [project-name (second args)]
     (fs/mkdir project-name)
     (fs/mkdir (str project-name "/dot"))
     (fs/mkdir (str project-name "/diagrams"))
     (fs/mkdir (str project-name "/domains"))
     (fs/mkdir (str project-name "/problems"))
     (fs/create (io/file (str project-name "/domain.pddl")))
     (fs/create (io/file (str project-name "/p01.pddl"))))

   ;; -l flag for adding locations in \textsc{pddl} file
   (= (second args) "-l")
   (let [content (add-part-to-\textsc{pddl} (first args)
                                   'init
                                   (calc-distance-good
                                    (get-specified-inits-in-pddl-file (first args)
                                                                      'location)))
         new-filename (clojure.string/replace-first (first args)
                                                    #"(.+).pddl"
                                                    "$1-locations.pddl")] ; TODO: location as arg

     (write->file new-filename (pprint/pprint content)))


   ;; Write dot graph to file.
   :else
   (let [input-domain (first args)
         new-dot-filename (find-new-file-name "dot/dot-diagram" ".dot")
         new-png-filename (find-new-file-name "diagrams/png-diagram" ".png")
         input-domain-filename (fs/name input-domain)
         domain-version (find-new-file-name
                         (str "domains/" input-domain-filename) (fs/extension input-domain))]

     ;; Save input domain version in folder domains.
     (fs/copy+ input-domain domain-version)     

     ;; Create folders for dot files and png diagrams
     (fs/mkdir "dot")
     (fs/mkdir "diagrams")

     ;; Create dot language file in dot folder.
     (doall
      (write->file new-dot-filename
                   (print (\textsc{pddl}->dot-file-input input-domain))))

     ;; Create a png file from dot
     (fs/exec "dot" "-Tpng" "-o" new-png-filename new-dot-filename)

     ;; Settings for displaying the generated diagram.
     (def img (ref nil))

     (defn setup []
       (quil/background 0)
       (dosync (ref-set img (quil/load-image new-png-filename))))

     (def img-size
       (with-open [r (java.io.FileInputStream. new-png-filename)]
         (let [image (javax.imageio.ImageIO/read r)
               img-width (.getWidth image)
               img-height (.getHeight image)]
           [img-width img-height])))

     (defn draw []
       (quil/image @img 0 0))

     ;; Display png file in JFrame.
     (exit-on-close
      (quil/sketch
       :title (str "\textsc{pddl} Type Diagram - " input-domain-filename)
       :setup setup
       :draw draw
       :size (vec img-size))))))
#+END_SRC

#+BEGIN_SRC text
# [PackageDev] target_format: plist, ext: tmLanguage
---
name: \textsc{pddl}
scopeName: text.pddl
fileTypes: [pddl]
uuid: 2aef09fc-d29e-4efd-bf1a-974598feb7a9

patterns:

#####################
### Customization ###

- include: '#domain'
- include: '#problem'
- include: '#comment'

##################
### Repository ###

repository:


##############################
### General specifications ###
##############################

  built-in-var:
    match: \?duration 
    name: variable.language.pddl

  variable:
    match: '(?:^|\s+)(\?[a-zA-Z](?:\w|-|_)*)'
    # name: variable.other.pddl
    name: keyword.other.pddl # TODO: changeback again to variable.other.pddl
    # this is just a dirty hack for highlighting

  pddl-expr:
    match: '(?:^|\s+)([a-zA-Z](?:\w|-|_)*)(?!:|\?)\b'
    captures:
      '1': {name: string.unquoted.pddl}
    #name: string.unquoted.pddl

  comment:
    comment: "Comments beginning with ';'"
    name: comment.line.semicolon.pddl
    match: ;.*

  number:
    name: constant.numeric.pddl
    match: \b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\.?[0-9]*)|(\.[0-9]+))((e|E)(\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\b

  keyword:
    name: storage.type.pddl # TODO: UPDATE
    match: :(constraints|metric|length)


######################
### Domain Helpers ###
######################


  function-keyword:
    name: support.function.pddl
    match: (assign|scale-up|scale-down|increase|decrease)


  # TODO
  other-keyword:
    name: support.other.pddl
    comment: "Remove parent or do sth that the paren isn't highlighted"
    match: \b(forall|(at\s+(start|end))|over)\b


  language-constant:
    name: constant.language.pddl
    match: (start|end|all)

  action-keyword:
    name: keyword.operator.pddl
    match: ':(?i:(parameters|vars|precondition|effect))(?!:|\?)\b'

  durative-action-keyword:
    name: keyword.operator.pddl
    match: ':(?i:(parameters|vars|duration|condition|effect))(?!:|\?)\b'



#############################
### Domain specifications ###
#############################

  domain:  
    patterns:
    - comment: "domain definition "
      name: meta.function.pddl
      begin: '\(\s*((?i:define))\b(?!\s+\(problem)'
      beginCaptures:
        '1': {name: storage.type.pddl}
      end: '\)'
      patterns: 
        - include: '#comment'
        - include: '#domain-name-in-define'
        - include: '#requirement'
        - include: '#types'
        - include: '#constants'
        - include: '#predicates'
        - include: '#new-functions'
        - include: '#action'
        - include: '#durative-action'
        - include: '#any-sexpr'


  domain-name-in-define:
    patterns:
      - comment: "Domain name in problem file"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(domain))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#comment'
          - name: invalid.illegal.pddl
            match: (\s+(?:\w|-)+){2,}
          - include: '#pddl-expr'

  requirement:
    patterns:
      - comment: "Requirement"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:requirements))\b'
        beginCaptures:
          '1': {name: storage.type.pddl}
        end: '\)'
        patterns:
        - name: keyword.other.pddl
          match:  :(?i:(strips|typing|negative-preconditions|disjunctive-preconditions|equality|existential-preconditions|universal-preconditions|quantified-preconditions|conditional-effects|fluents|numeric-fluents|object-fluents|adl|durative-actions|duration-inequalities|continuous-effects|derived-predicates|timed-initial-literals|preferences|constraints|action-costs))\b

  types:
    patterns:
      - comment: "Types"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:types))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - name: meta.keyword.pddl
            captures:
              '1': {name: constant.character.pddl}
              #'1': {name: string.unquoted.pddl}
              '2': {name: entity.name.function.pdd}
            match:  (-)(?:^|\s+)([a-zA-Z](?:\w|-|_)*)
          - include: '#either'
          - include: '#pddl-expr'
          - include: '#any-sexpr'

  constants:
    patterns:
      - comment: "Constants"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:constants))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - name: meta.keyword.pddl
            captures:
              '1': {name: entity.name.function.pddl}
              #'1': {name: string.unquoted.pddl}
              '2': {name: entity.name.tag.pddl}
            match:  (-)(?:^|\s+)([a-zA-Z](?:\w|-|_)*)
          - include: '#either'
          - include: '#pddl-expr'

  predicate:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#variable'
          - name: meta.name.function.pddl
            captures:
              '1': {name: constant.character.pddl}
              '2': {name: entity.name.function.pddl}
            match: (-)(?:^|\s+)([a-zA-Z](?:\w|-|_)*)

  init-predicate:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#pddl-expr'
          - include: '#number'
          - include: '#init-predicate-other'

  init-predicate-other:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#pddl-expr'
          - include: '#number'
          - include: '#init-predicate'

  applied-predicate-other:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#variable'
          - include: '#pddl-expr'
          - include: '#applied-predicate'

  applied-predicate:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#variable'
          - include: '#pddl-expr'
          - include: '#applied-predicate-other'


  function:
    patterns:
      - begin: '\(\s*((?:\w|-)+)'
        end: '(\)\s+-\s+((?:\w|-)+))'
        endCaptures:
          '2': {name: storage.type.pddl}
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#variable'
          - name: meta.name.function.pddl
            captures:
              '1': {name: entity.name.function.pddl}
            match: '-\s+((?:\w|-)+)'


  function-with-either:
    patterns:
      - begin: '\((\w+)'
        end: '(\)\s+-\s+((?:\w|-)+))|\)'
        endCaptures:
          '2': {name: storage.type.pddl}
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#variable'
          - name: meta.name.function.pddl
            captures:
              '1': {name: entity.name.function.pddl}
            match: '-\s+((?:\w|-)+)'

  predicates:
    patterns:
      - comment: "Predicates"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:predicates))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#predicate'
          - include: '#any-sexpr'


  connected-predicate-other:
    patterns:
      - comment: "Predicates that are connected via and, or, etc."
        #name: string.unquoted.pddl # TODO: NAME
        begin: '\((and|or|eq|neq|not|=|>=|<=|assign|increase|decrease|scale-up|scale-down|forall|exists|imply|when|\+|-|\*|/)\b'
        end: '\)'
        beginCaptures:
          '1': {name: string.unquoted.pddl}
        patterns:
          - include: '#typed-variable-list'
          - include: '#connected-predicate'
          - include: '#applied-predicate'
          - include: '#variable'
          - include: '#pddl-expr'

  connected-predicate:
    patterns:
      - comment: "Predicates that are connected via and, or, etc."
        name: meta.type.pddl # TODO: NAME
        begin: '\((and|or|eq|neq|not|=|>=|<=|assign|increase|decrease|scale-up|scale-down|forall|exists|imply|when|\+|-|\*|/)\b'
        end: '\)'
        beginCaptures:
          '1': {name: string.unquoted.pddl}
        patterns:
          - include: '#typed-variable-list'
          - include: '#connected-predicate-other'
          - include: '#applied-predicate'
          - include: '#variable'
          - include: '#pddl-expr'

# TODO:
  functions:
    patterns:
      - comment: "Functions"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:functions))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#function'
          - begin: '\((either)'
            beginCaptures:      
              '1': {name: entity.name.function.pddl}
              '2': {name: storage.type.pddl}
            patterns:
              - include: '#pddl-expr'
            end: '\)'
         #- include: '#function-with-either'

  either:
    patterns:
      - begin: '(-)\s+\((either)'
        beginCaptures:      
          '1': {name: entity.name.function.pddl}
          '2': {name: storage.type.pddl}
        patterns:
          - include: '#pddl-expr'
        end: '\)'

  new-functions:
    patterns:
      - comment: "Functions"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:functions))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#either'
          - include: '#predicate'
          - include: '#pddl-expr'

  typed-variable-list:
    patterns:
      - begin: '\((\?((?:\w|-)+))'
        end: '\)'
        beginCaptures:
          '1': {name: keyword.other.pddl}
        patterns:
          - include: '#variable'
          - name: meta.name.function.pddl
            captures:
              '1': {name: constant.character.pddl}
              '2': {name: entity.name.function.pddl}
            match: '(-)(?:^|\s+)([a-zA-Z](?:\w|-|_)*)(?!:|\?)\b'

  precondition:
    patterns:
      - name: entity.name.function.pddl
        begin: ':precondition\s*'
        end: \b

 # any-sexpr:
 #   patterns:
 #     - match: \(.*\)
 #       patterns:
 #         - include: '$self'


  any-sexpr:
    patterns:
      - begin: '\('
        end: '\)'
        patterns:
          - include: '#any-sexpr-other'
          - match:  (?:\s)*

  any-sexpr-other:
    patterns:
      - begin: '\('
        end: '\)'
        patterns:
          - include: '#any-sexpr'
          - match: (?:\s)*

  action:
    patterns:
      - comment: "Action"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:action))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#connected-predicate'
          - include: '#applied-predicate'
          - include: '#pddl-expr'
          - include: '#comment'
          - include: '#typed-variable-list'
          - include: '#action-keyword'
          - include: '#built-in-var'
          - include: '#any-sexpr'

  durative-action:
    patterns:
      - comment: "Durative Action"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:durative-action))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#connected-predicate'
          - include: '#applied-predicate'
          - include: '#pddl-expr'
          - include: '#comment'
          - include: '#typed-variable-list'
          - include: '#durativ-action-keyword'
          - include: '#built-in-var'
          - include: '#any-sexpr'

#######################
### Problem Helpers ###
#######################

  problem-name-in-define:
    patterns:
      - comment: "Domain name in problem file"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(problem))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#comment'
          - name: invalid.illegal.pddl
            match: (\s+(?:\w|-)+){2,}
          - include: '#pddl-expr'

  domain-name-in-problem:
    patterns:
      - comment: "Domain name in problem file"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:domain))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#comment'
          - name: invalid.illegal.pddl
            match: (\s+(?:\w|-)+){2,}
          - include: '#pddl-expr'

##############################
### Problem specifications ###
##############################


  problem:  
    patterns:
    - comment: "problem definition"
      name: meta.function.pddl
      begin: '\(\s*((?i:define))\b'
      beginCaptures:
        '1': {name: storage.type.function-type.pddl}
      end: '\)' # Paren after the domain/problem name.
      patterns: 
        - include: '#comment'
        - include: '#problem-name-in-define'
        - include: '#domain-name-in-problem'
        - include: '#inits'
        - include: '#objects'
        - include: '#goal'

  objects:
    patterns:
      - comment: "Objects"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:objects))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - name: meta.keyword.pddl
            captures:
              '1': {name: entity.name.function.pddl}
              #'1': {name: string.unquoted.pddl}
              '2': {name: entity.name.tag.pddl}
            match:  (-)(?:^|\s+)([a-zA-Z](?:\w|-|_)*)
          - include: '#either'
          - include: '#pddl-expr'

  inits:
    patterns:
      - comment: "Initalized predicates"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:init))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#init-predicate'
          - include: '#connected-predicate'
          - include: '#any-sexpr'

  goal:
    patterns:
      - comment: "Goal"
        name: meta.type.pddl # TODO: NAME
        begin: '\(\s*(?i:(:goal))\b'
        end: '\)'
        beginCaptures:
          '1': {name: storage.type.pddl}
        patterns:
          - include: '#connected-predicate'
          - include: '#applied-predicate'
          - include: '#comment'
          - include: '#any-sexpr'


# TODO: Metric
#+END_SRC

* Export Configuration                                     :ARCHIVE:noexport:
#+TITLE:  My\textsc{pddl} - A Modular Knowledge Engineering System for the Planning Domain Definition Language
#+AUTHOR: Volker Strobel
#+EMAIL: volker.strobel87@gmail.com
#+HTML: <div class="container">
#+LANGUAGE: en
#+OPTIONS: toc:t todo:nil
#+LATEX_CLASS: report
#+LaTeX_CLASS_OPTIONS: [a4paper,12pt]
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage[bibstyle=numeric,citestyle=numeric,backend=biber]{biblatex}
#+LaTeX_HEADER: \addbibresource{bibliography.bib}
#+LaTeX_HEADER: \usepackage[]{hyperref}
##+LaTeX_HEADER: \usepackage[]{keystroke}
#+LaTeX_HEADER: \hypersetup{hidelinks}
##+LATEX_HEADER: \usepackage{fontspec}
##+LATEX_HEADER: \usepackage{libertineotf}
#+LaTeX_HEADER: \usepackage[]{nomencl}
#+LaTeX_HEADER: \usepackage{svg}
#+LaTeX_HEADER: \usepackage{xspace}
#+LaTeX_HEADER: \usepackage{dirtree}
#+LaTeX_HEADER: \usepackage[autostyle]{csquotes} 
#+LaTeX_HEADER: \definecolor{dhscodebg}{rgb}{0.95,0.95,0.95}
#+LaTeX_HEADER: \usepackage{menukeys}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{scalefnt}

##+LaTeX_HEADER:% \newcommand{\mypddl}{\textsc{myPddl}\xspace}
#+LaTeX_HEADER: \newcommand{\mypddl}{\smallerft[0.8]{myPDDL}\xspace}
#+LaTeX_HEADER: \newcommand{\pddlstudio}{\textsc{pddl studio}\xspace}
#+LaTeX_HEADER: \newcommand{\itsimple}{\textsc{itSimple}\xspace}
#+LaTeX_HEADER: \newcommand{\pddlmode}{\textsc{pddl}-mode\xspace}
#+LaTeX_HEADER: \newcommand{\pddl}{\textsc{pddl}\xspace}
#+LATEX_HEADER: \newcommand\smallerft[2][0.85]{{\scalefont{#1}#2}}


#+OPTIONS org-export-publishing-directory "./exports"
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/bootstrap.css" />
** TODO: Glossary?
   
