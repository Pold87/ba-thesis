#+BEGIN_ABSTRACT
Writing and maintaining planning problems, specified in the widely
used /Planning Domain Definition Language/ (\textsc{pddl}), can be
difficult, time-consuming and error-prone. This thesis will present
\mypddl, a toolkit that helps knowledge engineers to develop,
visualize and manipulate \pddl planning task specifications. With
\mypddl, structured \pddl projects can be created and edited using
code templates and syntax highlighting. One tool visualizes the type
hierarchy in \pddl domains, allowing knowledge engineers to understand
the representation structure at a glance and to also keep track of
developments with a basic revision control system. Another tool allows
calculating distances between objects specified by predicates in a
problem file. These tools make use of an interface that provides a
general way for reading and writing \pddl specifications by using the
programming language Clojure, and thus presenting a means of bypassing
\pddl's limited modeling capacity. They are made accessible in the
customizable editor Sublime Text. A small user study, conducted with
eight inexperienced \pddl users, shows some initial evidence that the
syntax highlighting feature and the automated creation of type
diagrams could support knowledge engineers in the design and analysis
process. The users detected 35 % more errors using the syntax
highlighter in the same time as non-users and the average task
completion time for questions on a hierarchical domain was reduced by
52 %.
#+END_ABSTRACT

* Introduction
<<ch:introduction>>

Have you ever struggled to find the optimal sequence of actions for a
recurrent problem? While a task like this could take you hours, weeks
or even a lifetime to complete, a planning software could possibly get
the job done within milliseconds. Being a key aspect of artificial
intelligence, planning is concerned with devising a plan, i.e. a
sequence of actions, to achieve a desired goal
\cite{helmert2008understanding}. It can be both a tool to create
automated systems and a means to support and understand human behavior
\cite{konar1999artificial}. However, the effectiveness of planning
largely depends on the quality of the problem formalization
\cite{shah2013knowledge,keps2014}. To ensure a standardized modeling
format, the Planning Domain Definition Language (\textsc{pddl})
\cite{mcdermott1998pddl} was developed and has become the de facto
standard for the description of planning tasks
\cite{ilghami2005extension}. The discipline that deals with the
integration of world information into a computer system via a human
expert is called knowledge engineering \cite{feigenbaum1983fifth}.
While automated planning could save you a vast amount of time if
everything works as intended, creating the planning task
specifications is a complex task that can be error-prone and
cumbersome. Searching for an error in a long \pddl file can be like
looking for a needle in a haystack; debugging could take hours as some
planners crash on erroneous \pddl files without providing any problem
report.

The strenuous modeling process and the efficiency issues it brings
gave rise to the need for tools designed for creating planning task
specifications \cite{shah2013knowledge}, so much so that the annual
International Conference on Automated Planning and Scheduling [fn:25] has
workshops (such as Knowledge Engineering for Planning and Scheduling),
tutorials and presentations dedicated to this topic. Therefore,
developing such tools for \pddl and hence facilitating the knowledge
engineering process is appreciated and worthwhile.


The modular toolkit \mypddl (\textit{m}odeling efficientl\textit{y}
\pddl was developed, within the scope of this thesis, in order to
tackle frequent needs of knowledge engineers, like project management,
efficient development, error-detection, team collaboration and to
increase the acceptance and usage of \pddl in real-world domains
\cite{shah2013knowledge,keps2014}.


Challenges in implementing tools for knowledge engineers are the
different range of needs and demands of knowledge engineers.
Ease-of-use, To acceptance and the flexibility so that and the and the
are accepted and used. Different domains require different tools,
different knowledge engineers require different tools
nevertheless a toolkit should be able to work on a broad range. generality of domains


\mypddl is intended to support knowledge engineers throughout the
entire design cycle of specifying planning tasks. In the initial
stages, it allows for the creation of structured \textsc{pddl}
projects that should encourage a disciplined design process. With the
help of snippets, i.e. code templates, often used constructs can be
inserted in \textsc{pddl} files. A syntax highlighting feature that
speeds up the error-detection can come in handy in intermediate
stages. Understanding the textual representation of complex type
hierarchies in domain files can be confusing, so an additional feature
enables their visualization. \textsc{pddl}'s limited modeling
capabilities were bypassed by developing an interface that converts
\textsc{pddl} code into Clojure \cite{hickey2008clojure} code and vice
versa. Within this project, the interface was employed for a feature
that calculates distances between objects specified in a problem
model, but the interface provides numerous other possibilities and
could also be used to further automate the modeling process. All of
these features were integrated into the customizable and extensible
Sublime Text \cite{sublimetext2} editor.Since the main aim in the
development of the toolkit was for it to be easy to use and maintain,
it is evaluated with regard to these criteria. The usability was
assessed by means of a user test with eight subjects that had no prior
experience with artificial intelligence planning. The results indicate
that both error-detection and the understanding of a given domain can
be facilitated by \mypddl.

To lay the foundations for this thesis, a basic introduction to and
design principles for \pddl will be given in Chapter [[ch:basics]].
Existing tools will be critically reviewed in Chapter [[ch:related]] to
set the goals for \mypddl. The features and modules of \mypddl are then
described in detail in Chapter [[ch:tools]]. Details and results of the
usability study are provided in Chapter [[ch:evaluation]]. Finally, the
implications are briefly discussed before an outlook for future
research and developments in the field concludes this thesis in
Chapter [[ch:conclusion]].

[fn:25] More information on \textsc{icaps} 2014, the 24th
International Conference on Automated Planning and Scheduling can be
found on http://icaps14.icaps-conference.org/.

* Background and Basics
<<ch:basics>>

The human brain is an astonishing structure that allows us to get by
in a highly complex world and give more or less rational reasons for
our past or planned actions. While computer systems are yet to fully
master these skills, the study of artificial intelligence tries to
narrow this gap \cite{akerkar2012intelligent}. For this purpose,
constructs are needed that can represent the information about the
world and the problem. In automated planning, this is usually done
\cite{fox2003pddl2} using a planning language, like \textsc{pddl}.

To illustrate the usage and basics of \textsc{pddl}, the remainder of
this section presents a modeling walkthrough using a fictional
example.

Consider the following world that is to be integrated into a computer
system using \textsc{pddl}:

#+BEGIN_QUOTE
/Hacker World/ \\
If hackers are hungry, they have to eat some pizza in order to be able
to work, that is to exploit (or hack into) vulnerable software.
#+END_QUOTE
In this description, we can identify several constructs that should
somehow be integrated into the computer. There are:

- Types of entities:  :: The world consists of hackers, software and
     pizza.
- Logical states: :: Hackers can be hungry or not, software can be
     vulnerable or not, software can be exploited or not.
- Actions: :: Hackers can exploit software and they can eat pizza.
This description of a world can be specified in \textsc{pddl} using a
domain file. The domain file can be compared to a stage setting,
providing the framework for a specific problem scenario by way of
general, abstract constructs and conditions.

In the world of hackers and pizzas, such a domain specific problem
could be:

#+BEGIN_QUOTE
/Gary's Huge Problem/ \\
Gary is a hungry hacker who should somehow exploit the vulnerable
software MagicFailureApp. Some pepperoni pizza is lying around.
#+END_QUOTE
Again, several constructs can be identified:

- Objects :: The hacker Gary (in \textsc{pddl} all entities are
             objects, including persons), the pepperoni pizza, the
             software.

- Initial state :: Gary is hungry and the software MagicFailureApp
                   is vulnerable.

- Goal state :: The MagicFailureApp is exploited.
Assume that Gary wants the help of an automated planning system to
plan the sequence of required actions (/Who has to eat pizza?/, /What
should be hacked?/ and /In what order should these things be done?/),
leading from the initial state to the goal state. These specifications
must be formalized so that a planner can utilize them. In
\textsc{pddl}, this is done in problem files. In the end, Gary will be
able to feed the domain and the problem file into a planner which will
generate a sequence of actions that Gary can take to solve his
problem.

Summing up, \textsc{pddl} planning tasks specifications
are composed of two separate, corresponding files:

- Domain file: :: General, problem-independent description of types,
                 predicates (logical states) and actions.

- Problem file: :: Specification of a concrete problem within a
                  particular domain, expressed by the initial state
                  and the goal state. Specific values are assigned to
                  the templates provided by the domain file
                  (instantiation). 
This separation allows for a powerful task modeling process: while
general world information is described in the domain file, specific
instances of problems are created in the problem files. This means
that one abstract model of a world can be used for solving many
problem instances.

The rest of this section is to propose general design guidelines for,
and give an introduction to \textsc{pddl} [fn:5], to serve as a basis
for the rest of this thesis. To this end, the syntax of common
constructs of domain and problem files is further investigated in a
step-by-step approach, continuing with the above described example.

[fn:5] More complete descriptions of \textsc{pddl}, as well as
formulations in Backus-Naur form (BNF) are provided by
\textcite{fox2003pddl2} for \textsc{pddl} 2.2 and
\textcite{kovacs2011bnf} for \textsc{pddl} 3.1.

** Analysis

How do you begin to model a planning task? The first, and possibly
most significant step to integrate information into a computer system,
is gaining an /understanding/ of the problem
\cite{polya2008solve,helmert2008understanding}. For modeling in
\textsc{pddl}, the following six general design principles [fn:11]
ought to lead to a thorough, stepwise, and iterative modeling process:

- Analysis: :: Every task specification should begin with an analysis
               of the informal world and the problem statement. In
               this design step, one determines relevant types,
               adequate examples and identifies both the initial and
               the goal state.

- Type diagram: :: Based on the preceding analysis, the relationship
                   of the identified categories or types is
                   represented, using a diagram. This can be done on
                   paper or with the help of a graph editor.

- Domain definition: :: In this step, the diagrams are translated into
     \textsc{pddl}. Furthermore predicates and actions are declared.

- Problem definition: :: After completing the domain definition,
     objects can be instantiated in the problem file. The initial and
     goal states are modeled using the predicates declared in the
     domain file.

- Planning: ::  Now, one can provide the domain and problem definition
                to a planner. The planner then generates a plan, i.e. a
                sequence of actions that leads to the goal state.

- Plan analysis: :: Finally, the generated plan needs to be inspected.
                    If any design mistakes or inconistencies are
                    detected, it is advisable to restart at an earlier
                    design step.

The following two sections deal with the creation of a domain and
problem definition. At the end of the introduction of each construct,
the corresponding code block of the /Hacker World/ and /Gary's Huge
Problem/ is given.

[fn:11] These design principles are based on
\citetitle{felleisen2010design} that describes four steps of designing
class hierarchies for object-oriented programs.

** Domain File

The domain file sets the framework for planning tasks. It models the
world in which the problem occurs and hence determines which types and
predicates are available and which actions are possible.

***  Domain Definition

We begin with the definition of the domain file. Every domain file
starts with =(define (domain DNAME) ...)=, where =DNAME= specifies the
name of the domain. A semicolon (=;=) declares the rest of the line as
comment.

#+CAPTION: The domain definition of the /Hacker World/
#+BEGIN_SRC text :tangle garys-hacker-world.pddl
; Hacker World - A realistic example
(define (domain hacker-world)
#+END_SRC

*** Requirements

\pddl is composed of feature subsets \cite{mcdermott1998pddl}.
As most planners only support some of these subsets, the requirements
block is useful for a planner to determine if it can act on a given
problem. While basic specifications are used by default
\cite{mcdermott1998pddl}, further requirements have to be stated
explicitly. For example, one requirement used by many planning domains
\cite{wickler2011using} is:

- :typing :: Enables the typification of variables (see
             [[subsubsec:types]] Types below), so that it is mandatory for
             variables to be of a particular type.

Besides =:typing=, the /Hacker World/ will use a further
requirement:

- :negative-preconditions ::  Allows for the specification of negative
     preconditions in actions, so that an action can only be executed
     if a predicate is not true initially.

#+CAPTION: The requirements that are necessary to model the /Hacker World/
#+BEGIN_SRC text :tangle hacker-world.pddl
(:requirements :typing
               :negative-preconditions)
#+END_SRC

*** Types
<<subsubsec:types>>
Often in the real-world, there will be individual objects of the same
kind or type. There may be many different desks, but all share
common properties, like having a flat upper surface, and all are
pieces of furniture.

\pddl allows for declaring types and thereby structuring the
domain in the =(:types ...)= block. Relations can be expressed with a
type hierarchy, in which any type can be a subtype of yet another
type. Typed lists are used to assign types to variables.
Parameters in actions, as well as arguments in predicates can be typed
in this manner. Later, in the problem file, objects are assigned to
types. Types are declared using a list of strings, followed by a
hyphen (=-=), followed by the higher-level type. Every \pddl
domain includes the built-in types =object= and =number=, and every
defined type, in turn, is a subtype of =object=.

#+CAPTION: The type hierarchy for the /Hacker World/, consisting of different
#+CAPTION: types of persons, furniture, computers, hackers, food, pizza and software.
#+CAPTION: The elements on the left-hand side
#+CAPTION: (for example =hacker non-hacker=) are declared subtypes of the right-hand
#+CAPTION: side (=person=) whereby the type hierarchy is expressed. 
#+BEGIN_SRC text :tangle hacker-world.pddl
  (:types hacker non-hacker - person
          desk chair - furniture
          laptop workstation - computer
          pizza burgers fries - food
          pepperoni supreme - pizza
          person furniture compiter food software - object)
#+END_SRC

*** Predicates

How can we describe properties of objects and states of the world?
Predicates are templates to represent logical facts and can be either
true or false. In the =:(predicates ...)= block, predicate names and
the number of arguments together with the corresponding types are
declared. The general syntax for a predicate is =(pname ?v1 - t1 ?v2 -
t2 ...)=, where =?= followed by a name (=v1=, =v2=) declares a
variable, and the expression (=t1=, =t2=) following the hyphen (=-=)
states the type of this variable. All the types that are used must be
declared in the typing section first. The number of variables (or
arguments) determines the arity of a predicate ranging from zero
(nullary predicate) to any positive integer (n-ary predicate). Type
assignments for variables that have the same type and are declared
side by side can be grouped, meaning that =(p ?v1 - t ?v2 - t)= is
equivalent to =(p ?v1 ?v2 - t)=.

#+CAPTION: This section declares
#+CAPTION: five predicates: the unary predicates
#+CAPTION: =hungry=, =vulnerable= and =exploited=, the binary predicate =has=,
#+CAPTION: and the 3-ary predicates =location= that specifies x and y coordinates for objects,
#+CAPTION: =distance= that expresses the distance between objects.
#+BEGIN_SRC text :tangle garys-hacker-world.pddl
  (:predicates (has ?s - software ?p - person)
               (hungry ?p - person)
               (vulnerable ?s - software)
               (exploited ?s - software)
               (distance ?o1 ?o2 - object ?x - number)
               (location ?o - object ?x ?y - number))
#+END_SRC

*** Actions

Now that we have predicates for describing world states, we still need
a means for changing their value. This is done with action. Actions
are operators in \textsc{pddl}, because they can change properties of
objects by changing predicate values, so that problems can be solved.
Actions usually consist of three parts:

- :parameters :: A (typed) argument list that determines which
                 variables can be used in the precondition and effect
                 part.

- :precondition :: A combination of predicates, all of which must be
                   true before an action can be executed. Therefore,
                   this part describes the applicability of an action.

- :effect :: Specifies the new values of the declared predicates, once
             the action has been completed. Therefore, it describes
             the post-condition of an action.

#+CAPTION: Three actions that can change logical values in the /Hacker World/. 
#+CAPTION: It is important to remember that predicate values keep being
#+CAPTION: true if an effect adds a logical fact. This is often not desired.
#+CAPTION: Consider the action move, that changes the location of a chair.
#+CAPTION: Only having the effect =(location chair ?new-x ?new-y)= would result in
#+CAPTION: the chair being located at two locations, at =?old-x= and =?old-y=
#+CAPTION: and the new, specified coordinates. Therefore, the old coordinates have to be
#+CAPTION: deleted, using =(not ...)=. The =:precondition= part can be omitted, if an
#+CAPTION: action should be always applicable.
#+BEGIN_SRC text :tangle hacker-world.pddl
  ;; Eat a delicious pizza
  (:action eat-pizza
    :parameters (?pi - pizza ?p - person)
    :precondition (and (hungry ?p)
                       (has ?pi ?p))
    :effect (and (not (hungry ?p))
                 (not (has ?pi ?p))))
  
  ;; Exploit vulnerable software of a victim
  (:action exploit        
    :parameters (?h - hacker ?s - software ?p - person)
    :precondition (and (has ?s ?p)
                       (vulnerable ?s)
                       (not (hungry ?h)))
    :effect (exploited ?s))
  
  ;; Move a piece of furniture
  (:action move
    :parameters (?f - furniture ?old-x ?old-y ?new-x ?new-y)
    :effect (and (location ?f ?new-x ?new-y)
                 (not (location ?f ?old-x ?old-y)))))
#+END_SRC

** Problem File

A planning problem consists of a domain and a corresponding problem
file. Within problem files, concrete objects are created
(instantiated). Furthermore, the initial world state and the desired
goal state that is to be reached are declared.

*** Problem Definition 

Analogous to the domain definition, problem files are initiated with
=(define (problem PNAME) ...)=, where =PNAME= declares the name of the
problem.

#+CAPTION: Initiating the problem file with the name garys-huge-problem
#+BEGIN_SRC text :tangle garys-huge-problem.pddl
(define (problem garys-huge-problem)
#+END_SRC
 
*** Associated Domain

Problems occur in worlds. Therefore, problem files are designed with
regard to domain files that need to be referenced at this point in the
problem file. This means that =DNAME= in =(:domain DNAME)= and =DNAME=
in =(define (domain DNAME) ...)= in the corresponding domain file have
to be identical.

#+CAPTION: The domain "hacker-world" is
#+CAPTION: the corresponding domain name to the problem garys-huge-problem
#+BEGIN_SRC text :tangle garys-huge-problem.pddl
(:domain hacker-world)
#+END_SRC


*** Objects

Since types are only empty shells, they need to be instantiated. This
is done in the =(:objects ...)= block. Instantiating types means that
concrete objects are assigned to the types.

#+CAPTION: This part assigns concrete objects to the type
#+CAPTION: templates. In this case, magicfailureapp - software means that the
#+CAPTION: object magicfailureapp is of the type application.
#+BEGIN_SRC text :tangle garys-huge-problem.pddl
  (:objects big-pepperoni - pepperoni
            gary - hacker
            gisela - non-hacker
            magicfailureapp - software)
#+END_SRC


***  Init

The =(:init ...)= block models the initial state of the world with a
list of instantiated predicates that are declared as true. All other,
non-specified predicates are assumed to be false. This is called the
/closed-world assumption/ [fn:4].

#+CAPTION: The initial situation in Gary's Huge Problem consists of the hungry
#+CAPTION: hacker Gary and the vulnerable application MagicFailureApp that
#+CAPTION: belongs to Gisela.
#+BEGIN_SRC text :tangle garys-huge-problem.pddl
  (:init (hungry gary)
         (has big-pepperoni gary)
         (vulnerable magicfailureapp)
         (has magicfailureapp gisela))
#+END_SRC

[fn:4] By specifying =:open-world= in the requirements part, \textsc{pddl} is
also capable of using the open world assumption, where non-specified
predicates can be both, true or false.


***  Goal

The goal state is described by the logical fact that is desirable and
should be reached with the execution of the plan. In \textsc{pddl},
several goals are combined with =(and ...)=. All unspecified predicates
are irrelevant, meaning that they can be either true or false in the
goal state.

#+CAPTION: In the end, the software magicfailureapp
#+CAPTION: should be exploited.
#+BEGIN_SRC text :tangle garys-huge-problem.pddl
(:goal (exploited magicfailureapp))
#+END_SRC


** Planning

Finally, the effort of the formalization of the planning task will be
rewarded with the automatic generation of a plan. There is a broad
range of available planners [fn:6]. However, most planners only
support certain subsets of \pddl and have some
peculiarities [fn:3]. Additionally, the quality of error messages is
very diverse, ranging from stating that an error occurred to
displaying line number and found problem.

This thesis uses the planner SGPlan_5 \cite{hsu2008sgplan}, a planner
that supports many \textsc{pddl} features and has comprehensive
error messages that state the actual problem [fn:9].

The planner SGPlan_5 can be used by specifying the domain file and
the problem file in a command line interface.

The relevant output lines for /Gary's Huge Problem/, specified in the
/Hacker World/ look as follows:
\vspace*{0.2cm}

#+BEGIN_SRC text
0.001: (EAT-PIZZA BIG-PEPPERONI-PIZZA GARY) [1]
1.002: (EXPLOIT GARY MAGICFAILUREAPP GISELA) [1]
#+END_SRC

The numbers to the left (=0.001=, =1.002=) and to the right (=[1]=)
specify the start time and the duration of the actions, respectively.
Since we did not use any timestamps, they are dispensable in this
case, because only the order of actions is relevant.

Gary now definitely knows that he first has to eat the pepperoni pizza
before he can exploit Gisela's application MagicFailureApp.

Since specifying \textsc{pddl} files can be time-consuming the next
chapter will compare knowledge engineering tools that support the user
in effectively eneffective planning model.

[fn:6] For an overview of planners that participated in the 2011
International Planning Competition and their features, see
http://www.plg.inf.uc3m.es/ipc2011-deterministic/ParticipatingPlanners.html.

[fn:3] A short discussion on planners and their "excentricities" can
be found at http://users.cecs.anu.edu.au/~patrik/pddlman/writing.html.

[fn:9] Additionally, SGPlan_5 was the winner of the 1st Prize
Satisficing Planning in the Deterministic Part of the International
Planning Competition (IPC) in 2006
http://zeus.ing.unibs.it/ipc-5/results.html.


* Related Work
<<ch:related>>

This chapter is to introduce knowledge engineering tools that allow
editing \textsc{pddl} files in a textual environment to some extent.
All tools provide features to support the user in writing correct
\textsc{pddl} code more efficiently. After introducing the tools, they
are compared and their shortcomings are discussed to set the stage for
\mypddl.

** PDDL Studio

\pddlstudio \cite{chomuttool,plch2012inspect} is an application for
creating and managing \textsc{pddl} projects, i.e. a collection of
\textsc{pddl} files. The \pddlstudio integrated development
environment (IDE) was inspired by Microsoft Visual Studio
\cite{visstudio} and imperative programming paradigms. Its main
features are syntax highlighting, error detection, context sensitive
code completion, code folding, project management, and planner
integration. Many of these features are based on a parser, which
continuously analyzes the code and divides it into syntactic elements.
These elements and the way in which they relate to each other can then
be identified. The syntax highlighter is a tool that colors constructs
according to their syntactical meaning within the code. In the case of
\pddlstudio, it colors names, variables, errors, keywords, predicates,
types and brackets each in a different customizable color.
\pddlstudio's error detection can recognize both syntax errors
(missing keywords, parentheses, etc.) and semantic errors (wrong type
of predicate parameters, misspelled predicates, etc.). Since semantic
errors can be of an interfile nature, meaning that there is a mismatch
between domain and problem file, \pddlstudio can detect such errors in
real time. The code completion feature allows for the selection of
completion suggestions for standard \textsc{pddl} constructs as well
as for terms that have been used before within this file or other
files in the same project. Code folding allows the knowledge engineer
to hide certain code units or blocks that are currently not needed.
Only the first line of the block is then displayed. \pddlstudio's code folding feature works on the basis of syntax. This means
that it can tell different code blocks apart with the help of the
parser and is thus able to fold the code accordingly. All these above
mentioned features of \pddlstudio utilize the parser. Another
important feature of the \pddlstudio project is a project
manager. This keeps track of all files, displays them in a tree
structure, saves them upon compilation and is also necessary for the
interfile error detection and code completion functionalities. Lastly,
a command-line interface allows the integration of planners in order
to run and compare different planning software.

** itSIMPLE

Unlike \pddlstudio, which provides a text based editor for \pddl, the
\itsimple \cite{vaquero2005itsimple} editor has, as its main feature, a
graphical approach that allows for designing planning tasks in an
object-oriented approach using Unified Modeling Language (\textsc{uml})
\cite{booch1999unified} diagrams. \textsc{uml} was invented in order
to standardize modeling in software engineering (SE) and the latest
version (\textsc{uml} 2.4.1) \cite{umllatest} consists of 14 different types of diagrams
divided into two larger groups: structure and behavior diagrams. In
the process leading up to \itsimple, \textsc{uml.p} (\textsc{uml} in a
Planning Approach) was proposed, a \textsc{uml} variant specifically
designed for modeling planning domains and problems
\cite{vaquero2006use}.

This variant specifies:

- Class Diagrams for static domain features
- Object Diagrams to describe the initial and the goal state in
  problem specifications
- StateChart Diagrams to represent dynamic characteristics such as
  actions in domain specifications.

Thus, \itsimple uses both \textsc{uml} structure diagrams (Class and
Object Diagrams) and \textsc{uml} behavior diagrams (StateChart
Diagrams). The main purpose of \itsimple is supporting knowledge
engineers in the initial stages of the design phase by making tools
available that help with the transition from the informality of the
real world to the formal specifications of domain models. The
professed aim of the project is to provide a means to a
\enquote{disciplined process of elicitation, organization and analysis
of requirements} \cite{vaquero2005itsimple}. However, subsequent
design stages are also supported. Once domain and problem models have
been created, \textsc{pddl} representations can be generated from the
UML.P diagrams, edited, and then used as input to a number of
different integrated planning systems. Therefore, one of the tools
already introduced within the scope of \pddlstudio, planner
integration, is also implemented. However, unlike in \textsc{pddl}
Studio, \itsimple has a more user-friendly approach to planner
integration: domain and problem can be fed to the planner with the
press of a button, while in \textsc{pddl} Studio, the user has to know
and input commands in a command-line interface.

Not only is it possible to directly input the domains and problems
into a planner, another tool can inspect the output from the planning
system using the built-in plan analysis. This consists of a plan
visualization that shows the interaction between the plan and the
domain by highlighting every change caused by an action. \itSimple's
modeling workflow is unidirectional, as changes in the \textsc{pddl} domain do
not affect the UML model and UML models have to be modeled manually,
meaning that they cannot by generated using \textsc{pddl}. Starting in version
4.0 \cite{vaquero2012itsimple4} \itsimple expanded its features to
allow the creation of \textsc{pddl} projects from scratch (i.e. without UML to
\textsc{pddl} translation process). Thus far, the \textsc{pddl} editing features are
basic. A minimal syntax highlighting feature recognizes \textsc{pddl} keywords,
variables, and comments. Furthermore, \itsimple provides templates for
\textsc{pddl} constructs, such as requirement specifications, predicates,
actions, initial and goal definitions.

** PDDL-Mode for Emacs

GNU Emacs is a text editor, primarily written in, and customizable by
using Emacs Lisp, a Lisp dialect
\cite{stallman1981emacs,lewis1990gnu}. The core values of Emacs are
its extensibility and customizability. \pddlmode \cite{pddlmode} is a
major Emacs mode, which determines the editing behavior of Emacs, for
browsing and editing \textsc{PDDL} files. It provides syntax
highlighting by way of basic pattern matching of keywords, variables
and comments. Additional features are automatic indentation and code
completion as well as bracket matching. Code snippets for the creation
of domains, problems and actions are also available. Finally, the
\pddlmode keeps track of action and problem declarations by adding
them to a menu and thus intending to allow for easy and fast code
navigation.

** Critical Review

All three tools, that have been described above, provide environments
for the creation of \pddl code. However, each comes with its own
advantages and disadvantages that are to be reviewed in this section.
At the end of each discussed feature, the approach that will be used
in \mypddl is introduced.

First and foremost, it must be mentioned that both \pddlstudio and
\itsimple were made from scratch, i.e. they do not build on existing
editors and therefore cannot fall back on refined implementations of
features that have been modified and improved many times throughout
their existence. Many of their features must be regarded against this
backdrop.

For instance, \pddlstudio has a parser implemented that enables code
folding on a syntactical basis. \pddl-mode for Emacs, on the other
hand could be customized to be capable of code folding either on the
basis of indentation or on a syntactic level. Not providing a simple
way to automatically indent code is one of the drawbacks of
\pddlstudio and \itsimple, since \enquote{in a large program, no
indentation would be a real hindrance and very difficult to use. The
same is true for overly indented programs.} \cite{miara1983program}.
Furthermore, both \itsimple and \pddlstudio specify horizontal tab
sizes of about ten spaces, while two to four spaces generally seem to
be adequate \cite{miara1983program}. To have both basic editor
features [fn:2] and a high customizability, it was decided to use an
existing, extensible text editor to integrate \mypddl into.

The tools can also be compared in terms of their syntax highlighting
capabilities. In \pddlmode for Emacs, keywords (up to \pddl 2.2),
variables, and comments are highlighted. However, this is only done
via pattern matching without controlling for context. This means that
wherever the respective terms appear within the code they will get
highlighted, regardless of the syntactical correctness. Therefore, it
is useful when the knowledge engineer is familiar with \pddl syntax,
but can also be misleading if this is not the case. Different colors
can be chosen by customizing Emacs. \itsimple's syntax highlighting
for \pddl 3.1 is, except for the \pddl version difference, equally as
extensive as that of \pddlmode for Emacs, but does not allow for any
customization. Despite placing a larger emphasis on the creation of
\pddl code from scratch within the \itsimple modeling environment,
syntax highlighting did not get more advanced with the latest version.
\pddlstudio has advanced syntax highlighting that distinguishes all
different \pddl \smallerft[0.8]{1.2} constructs, depending on the context, and allows
knowledge engineers to choose their preferred highlighting colors. One
of the primary objectives of \mypddl is to help users in keeping track
of their \pddl programs. As a means to this end, it was decided to
also implement sophisticated, context-dependent syntax highlighting.

Another feature that can be useful for fast programming, is the
ability to insert larger code skeletons or snippets. This allows the
knowledge engineer to focus on the specific domain and problem
characteristics instead of having to worry about the \pddl
formalities. \pddlstudio does not support the insertion of code
snippets at all. \itsimple features some code templates for
predicates, derived predicates, functions, actions, constraints,
types, comments, requirements, objects, and metrics. However, the
templates are neither customizable nor extensible. \pddlmode for Emacs
provides three larger skeletons, one for domains, one for problems and
one for actions. Further skeletons could be added. \mypddl aims to
combine the best of these latter tools and support customizable and
extensible snippets for domains, problems, types, predicates,
functions, actions and durative actions. In addition, to allow users
to easily navigate within snippets, the option of going from one blank
to the next by pressing the tabulator key \keys{\tab} on the keyboard
is also provided.

When it comes to visualization, neither \pddlstudio nor \pddlmode for
Emacs provide any visualization options. \itsimple, on the other hand,
is based entirely on visually modeling domains and problems.
Therefore, since the first version, the focus has mainly been on
exporting from \textsc{uml.p} to \pddl. \mypddl is to reverse this
design approach and enable type diagram visualization of some parts of
the \pddl code.

At this point, it must be mentioned that
\textcite{tonidandel2006reading} present a translation process, from a
\pddl domain specification to an object-oriented \textsc{uml.p} model
as a possible integration for \itsimple. This translation process
makes extensive semantic assumptions for \pddl descriptions. Two
default classes /Agent/ and /Environment/, corresponding to \pddl
types, are incorporated into the Class Diagram. The first parameter in
the =:parameters= section of an action is automatically declared as a
subclass of the class /Agent/. In addition, each action will be
allocated to the corresponding class of its first parameter in the
Class Diagram. Furthermore, the first argument of a predicate is
considered to be its main argument, so depending on their arity,
predicates would be visualized differently:

- Nullary predicates would be allocated as attributes of the type
  /Environment/.
- Unary predicates would be declared as attributes of the type of the
  specified parameter.
- Binary predicates would be regarded as associations, expressed by an
  labeled arrow from the type of the first parameter to the type of
  the second one.

The described method is limited, because predicates with an arity of
three or higher cannot be visualized. There is currently no \itsimple
version with this feature, according to an email from one of the
authors, Tiago Vaquero, dated March 11 2014. This approach makes
relatively large semantic assumptions that could distort the
visualization. In contrast, \mypddl allocates predicates to every
mentioned type in the variable list, and therefore allows for a
representation of arbitrary n-ary predicates (n > 0). Actions are not
visualized in \mypddl.

Searching for errors can be one of the most time consuming parts of
the design process \cite{gill1951diagnosis}. Hence, any tool that is
able to help detect errors faster is of great value to the knowledge
engineer. While \pddlmode for Emacs and \itsimple facilitate error
detection only by basic syntax highlighting, \pddlstudio not only has
syntactic but also semantic error detection implemented. Errors are
detected immediately when they are made, thanks to the parser, and a
dynamic table keeps track of them and provides error descriptions.
Even though the immediacy with which errors are highlighted and added
to the table can be helpful, it can also be premature at times. For
example just because the closing parenthesis was not typed yet, does
not mean it was forgotten. Therefore, for \mypddl the goal was to
implement a more subtle syntactic error detection. Syntactic errors
are simply not highlighted by the syntax highlighting feature, while
all correct \pddl code is highlighted. Even though checking for
semantic errors online should allow finding such errors before feeding
the program to a planner, and thus increase the probability of feeding
correct files to the planner, planning software is also able to detect
semantic errors. For this reason, it was decided not to implement
semantic error detection in \mypddl yet.


Another major drawback of \pddlstudio and \pddlmode for Emacs
especially, is that they are apparently not updated regularly to work
with the most recent \pddl versions. \pddlstudio's parser is only able
to parse \pddl 1.2, one of the first \pddl versions. As of writing
this thesis, the latest \pddl version is 3.1. It must be mentioned
that \pddl has evolved since \textsc{pddl} 1.2 and was extended in
\pddl 2.1 to include durative actions to model time dependent
behaviors, numeric fluents to model non-binary changes of the world
state, and plan-metrics to customize the evaluation of plans
\cite{fox2003pddl2}. \pddlmode for Emacs only works with \pddl
versions up to 2.2, which introduced derived predicates and timed
initial predicates \cite{edelkamp2004pddl2}, but does not recognize
later features like object-fluents, so that the range of functions,
specified in the domain file, cannot include object-types in addition
to numbers. \itsimple on the other hand is more regularly maintained
and \itsimple4.0 is in beta status since 2012 \cite{itsimpleonline}.
The release will be the first \itsimple version intended to also
support the creation of \pddl documents from scratch, meaning that the
text editor plays a much larger role in this version compared to
previous ones.

Finally, one of the most important features of any software is the
possibility of extending and customizing it
\cite{hui2003requirements}. Different programmers need to work with
many different tools and need them to have a similar look and feel;
they have different use cases and thus need different plug-ins and
extensions to meet their needs, or they may simply have different
preferences. \pddlstudio falls short of satisfying this requirement as
the customization features (without editing the source code) are
limited to the choice of font style and color of highlighted \pddl
expressions. Furthermore, \pddlstudio is written as standalone
program, meaning that there are no \pddl independent extensions. The
same holds true for \itsimple which is also not customizable without
editing the source code. Being an Emacs mode and Emacs being an
established text editor, \pddlmode is highly and easily customizable
and extensible.

This is the other major reason why it was decided that \mypddl should
be integrated into a existing, extensible, and customizable text
editor. These requirements are intended to be met by Sublime Text, a
text editor that sports such features as customizable key bindings,
display of line numbers and multi-line selection. In addition, there
is a broad range of extensions for Sublime Text, so that features like
revision control via Git, file management with a sidebar, color
highlighting of matching brackets or comparing and merging files can
be added. Furthermore, Sublime Text supports the majority of common
programming and markup languages, in order for users to use the same
tool and settings for programming and \pddl specifications. TODO:
Source for all that!

\mypddl is designed as a package for Sublime Text and provides
sophisticated syntax highlighting, code snippets, syntactical error
detection and type diagram visualization. Additionally, it allows for
the automation of modeling tasks due to a Clojure interface that
supports the conversion of \textsc{pddl} code into Clojure code and
vice versa. Therefore, the \mypddl shell supports both the initial
design process of creating domains (with code snippets, syntax
highlighting and the Clojure interface), and the later step of
checking the validity of existing domains and problems with the type
diagram generator. Lastly, since it is increasingly important that
several people work on one project together, the visualization
capabilities of \mypddl are meant to help users to understand each
other's code faster and thus be able to work with it more efficiently.

[fn:2] Features such as automatic indentation, selection of tab size,
defining custom key shortcuts, customizing the general look and feel,
displaying line numbers, and bracket matching.


* Knowledge Engineering Tools for Automated Planning
<<ch:tools>>
  
The /Hacker World/ and /Gary's Huge Problem/, presented in Chapter
[[ch:basics]], already indicated that writing and maintaining \pddl files
can be tedious \cite{li2012translating,zhuo2010learning}. \pddl's
modeling capabilities have been developed further with the release of
new \pddl versions \cite{fox2003pddl2,kovacs2011bnf} and it is likely
that it will be used for even more complex, realistic domains that are
designed by a team of experts instead of a single person
\cite{shah2013knowledge}. For these purposes, it is "generally
accepted that effective tool support is required to build domain
models" \cite[][p.53]{shah2013knowledge}.

This chapter presents \mypddl, a highly customizable
and extensible modular system, designed for supporting knowledge
engineers in the process of writing, analyzing and expanding \pddl
files and thereby promoting the collaboration between knowledge
engineers and the use of \pddl in real-world applications. 
It consists of the following, integral parts:

- \mypddl-new :: Create a \pddl project folder structure with \pddl
                 domain and problem skeletons.
- \mypddl-syntax :: A context-aware syntax highlighting feature.
- \mypddl-snippet :: Code snippets (templates), which can be inserted
     in \pddl files.
- \mypddl-distance :: Automated distance calculation for \pddl
     locations, specified in a problem file.
- \mypddl-diagram :: A type diagram generator for analyzing the
     structure of \pddl type hierarchies.
- \mypddl-IDE :: An integrated development environment for the use of
                 \mypddl in Sublime Text.

A general interface between \pddl and Clojure allows for bypassing
\pddl's limited mathematical modeling capacity and serves as a basis
for \mypddl-diagram and -distance.


** Create PDDL Projects (myPDDL-new)

Regardless of whether you are congenitally chaotic or organized,
\mypddl-new was designed so you do not have to worry about file and
folder management and can instead focus on the more essential parts of
the modeling process. In many cases, creating \pddl domains is an
ad-hoc process \cite{shah2013exploring}. However, each implementation
of a \pddl task specification comprises the creation of one domain and
at least a corresponding problem file. Since several team members may
be working on these files, having a structure for these \pddl projects
would be desirable. To this end, a standardized project folder
structure could facilitate the collaboration and maintenance of
consistency across projects and support a structured and organized
design process.

\mypddl introduces such a standardized project folder structure by
creating a new project folder on the basis of a project name. Figure
\ref{fig:mypddl-new-folder} illustrates the created structure and
files.

#+BEGIN_LATEX
\begin{figure}[h] 
  \dirtree{%
  .1 project-name/.
  .2 dot/.
  .2 diagrams/.
  .2 domains/.
  .2 problems/.
  .3 p01.pddl.
  .2 solutions/.
  .2 domain.pddl.
  .2 README.md.
  }
\caption[]{\label{fig:mypddl-new-folder}The project folder structure created by myPDDL-new.
\texttt{project-name} is chosen by the user and automatically used for the name
of the created domain.}
\end{figure}
#+END_LATEX
Within this project folder, the domain file =domain.pddl= and the
problem file =p01.pddl= (in the folder =problems=) are filled with
basic \pddl skeletons. The templates for the skeletons can be
customized to the user's needs by editing the template. \\
The folders =domains/=, =dot/=, and =diagrams/= are created for the
use with \mypddl-gen that saves its generated output to these folders
and thereby allows for a basic version control system (see [[subsec:gen]]
Type Diagram Generator (\mypddl-dia)). \\
As one domain file can have multiple problem files, the folder
=problems/= is designed for the collection of all associated problem
files. \\
Recognizing that knowledge engineers often do not write any
documentation related to the specified planning task
\cite{shah2013knowledge}, =README.md= is a Markdown file (a plain text
formatting syntax \cite{gruber2004markdown}), which is, among others,
intended for information about the author(s) of the project, contact
information, informal domain and problem specifications, and licensing
information. Markdown files are converted to \textsc{html} by various
hosting services that use the Git system (like GitHub, Bitbucket).
This file can hence be used as a quick overview for \pddl projects,
located at a hosting service (vllt die beiden sätze zusammenfügen) and
tackles the need for team work \cite{shah2013knowledge}. The choice of
a folder structure (instead of a project file that contains
information about the associated domain and problem files) has the
advantage of being readable and customizable independent of the
editor.

** Code Snippets (myPDDL-snp)

Consider again the basic skeleton of an action:

#+CAPTION: Skeleton of an \pddl action
#+NAME: ls-action-skeleton
#+BEGIN_SRC text
(:action action-name
	:parameters (?x - object)
	:precondition (and (pred-1))
	:effect (and ))
#+END_SRC          

Almost all \pddl actions consist of these same parts. Writing and
extending \pddl files, knowledge engineers therefore have to to use
the same constructs again and again. This is where code snippets come
in. To facilitate and speed up the implementation of standard
constructs, \mypddl-snp provides code skeletons, i.e. templates for
often used \pddl constructs, like domain and problem definitions,
predicates and actions. They can be inserted by typing a triggering
keyword. Typing =action= and pressing the tabulator key (\keys{\tab}),
inserts the action specified in Listing [[ls-action-skeleton]]. \pddl
constructs with a specified arity can be inserted by adding the arity
number to the trigger keyword (=p2= would insert the binary predicate
template =(pred-name ?x - object ?y - object)=.

Once the snippets has been inserted, skipping from blank to blank is
enabled by pressing tabulator key.

Therefore, having a means to easily navigate the snippets
would become handy. For this purpose, the blanks can be filled by
pressing \tab on the keyboard and thereby navigating inside the
snippet, so that the cursor will first mark the action-name .q
inserted content contains fields with placeholders, that can be
accessed and filled in consecutively.

Every snippet is stored in a separate file, located in the folder
=Packages/PDDL/= of Sublime Text. New snippets can be added and
existing snippets can be customized (change the template or the
triggering keyword) in this folder.

** Syntax Highlighting (myPDDL-syn)  
 <<sec:syntax>>

Continually growing \pddl files can span several pages and consist of
hundreds or thousands of lines of code. Thus detecting syntax errors
and keeping track of the file structure can be become a real challenge
for knowledge engineers. In order to recognize file elements quickly
and detect errors at a glance, highlighting syntactical constructs is
an established feature of text editors \cite{reijers2011syntax}.

\mypddl-syn is a \pddl context-aware syntax highlighting feature for
Sublime Text. It distinguishes all \pddl constructs up to version
3.1 [fn:16], like comments, variables, names, and keywords and
highlights them in different colors. Using regular expressions that
can both recognize the start and the end of code blocks by means of a
sophisticated pattern matching heuristic, \mypddl identifies and
divides \pddl code blocks and constructs in so called /scopes/, i.e.
named regions. Sublime Text colorizes the parts of the code by means
of the assigned scope names. These scopes allow for a fragmentation of
the \pddl files, so that constructs are only highlighted, if they
appear in the correct context [fn:15]. Thus missing brackets,
misplaced expressions and misspelled keywords are visually distinct
and can be identified. The look and feel of the highlighted
expressions can be alternated by changing Sublime Text's color scheme
which is responsible for the coloration [fn:14].

Figure \ref{fig:syntax-highlighting} displays an extract of the
deliberately erroneous domain /Coffee/, which was used in the user
study for the evaluation of this tool, with and without syntax
highlighted code. It can be seen that constructs that are not
specified by \pddl are also not highlighted (written in white).

#+BEGIN_LaTeX
      \begin{sidewaysfigure}
        \centering
        \begin{subfigure}[b]{0.49\textwidth}
          \includegraphics[width=0.8\textwidth]{img/coffee_yes.pdf}
          \caption{Using the syntax highlighting feature incorrect
            constructs can be easily identified as they are not
            highlighted and therefore displayed in white.}
          \label{fig:sh-coffee-yes}
        \end{subfigure}
        \begin{subfigure}[b]{0.49\textwidth}
          \includegraphics[width=0.8\textwidth]{img/coffee_no.pdf}
          \caption{The same domain as on the left hand side without syntax highlighting.}
          \label{fig:sh-coffee-no}
        \end{subfigure}%
      \caption{The deliberately erroneous domain \emph{Coffee} without \ref{fig:sh-coffee-yes}
        and with \ref{fig:sh-coffee-no} syntax highlighting, using the Sublime Text color
        scheme /Monokai/.}
        \label{fig:syntax-highlighting}
      \end{sidewaysfigure}
#+END_LaTeX


For the ease of creation, the \pddl syntax highlighter is implemented
by the use of the Sublime Text plug-in \textcite{aaapackagedev}. So,
the definitions can be written in YAML in converted to Plist
\textsc{xml} later on.

The YAML-tmlanguage file is organized into repositories, so that
expressions can be re-used in different scopes. This organization also
allows for a customization of the syntax highlighter. The default

The first part of the \pddl.YAML-tmlanguage describes the parts of the
\pddl task that should be highlighted. By removing (or commenting)
include statements, the syntax highlighter is adjustable the user's
need.

A key challenge of creating a context-aware syntax highlighter without
the availability of a lexical parser, is the use of regular
expressions for creating a preferably complete \pddl identification.
The consistency and capability to highlight every \pddl construct in a
color according to its meaning, were checked by 320 (syntax
error-free) \pddl files, consisting of 87 domain and 230 problem files
(list of files). In that, no inconsistencies nor non-highlighted words
could be found.

[fn:14] The extend to which the syntax highlighting is supported is
dependent on the used color scheme. By using the built-in Sublime Text
color scheme /Monokai/, all syntactically correct \pddl constructs get
highlighted. Non-highlighted (i.e. white) constructs either contain
syntactical errors or are not specified by \pddl3.1.

[fn:15] Context is meant in the sense of code blocks here. That means
is a construct written in ... =(:predicates ...)=) or =(:action ...)=

[fn:16] The regular expressions that are used to detect different
parts are based on the Backus-Naur Form (BNF) descriptions, formulated
in \textcite{kovacs2011bnf,fox2003pddl2,mcdermott1998pddl}.

** General Interface between PDDL and Clojure

Since \pddl is used to create more and more complex domains
\cite{goldman2012type,guerin2012academic} needing the square root
function for a distance optimization problem or the logarithmic
function for modeling an engineering problem does not seem to be a
far-fetched scenario. However, \pddl's calculating capabilities are
limited \cite{parkinson2012increasing}. While these mathematical
operations are currently not supported by \pddl itself, preprocessing
\pddl files in a programming language and then hardcoding the results
back into the file seems to be a reasonable workaround. With the help
of such an interface, the modeling time can reduced an even partly
automated (see [[subsec:loc]] the distance calculator \mypddl-loc). Once a
part is extracted and represented in Clojure, the processing
possibilities are diverse and the full capacities of Clojure can be
used. It can be used for generating \pddl constructs, reading domain
and problem files, handling, using and modifying the input, and
generating \pddl files as output.

Since \pddl's syntax is inspired by Lisp \cite{fox2003pddl2}, using a
Lisp dialect for the interface stood to reason. Consequently, file
input and output methods can use s-expressions (i.e. parenthesized
lists), resulting in convenient representations of and access to \pddl
files. For this thesis, it was decided to Clojure
\parencite{hickey2008clojure}, a modern Lisp dialect that runs on the
Java Virtual Machine (JVM) \cite{lindholm2011virtual}.

The interface is provided as a Clojure library and based on two
methods:
- read-construct(keyword, file) ::  Allows for the extraction of
     code blocks from \pddl files [fn:18]. Listing
     [[src:read-construct]] shows an example, where the goal state of
     /Gary's Huge Problem/ is extracted.

#+CAPTION: Extracting the goal state of /Gary's Huge Problem/ by using the interface.
#+NAME: src:read-construct
#+BEGIN_SRC clojure
(read-construct :goal "garys-huge-problem.pddl")
;;=> ((:goal (exploited magicfailureapp)))
#+END_SRC

- add-construct(file, position, part) :: Provides a means for adding
     constructs to a specified position in \pddl problem files.
     Listing [[src:add-construct]] displays the application of this method.

#+CAPTION: Adding the predicate (hungry gisela) to /Gary's Huge Problem/ using the PDDL/Clojure interface.
#+NAME: src:add-construct
#+BEGIN_SRC clojure
(add-construct "garys-huge-problem.pddl" :init '((hungry gisela)))
#+END_SRC

Subsequently, the modified part of the problem file looks like
follows: \hspace{0.3cm}
#+BEGIN_SRC text
...
 (:init
  (hungry gary)
  (vulnerable magicfailureapp)
  (has magicfailureapp gisela)
  (hungry gisela))
...
#+END_SRC

[fn:18] In doing so, it uses a safe reader method, provided by
     https://github.com/clojure/tools.reader that avoids that possibly
     harmful read-in constructs can be executed.


** Distance Calculation for PDDL Locations (myPDDL-loc)
<<subsec:loc>>

/Hacker World/ in Chapter [[ch:basics]], defines the predicate =(location
?f - furniture ?x ?y - number)=. A possible extension to this domain
would be an action that is only applicable if a person is within a
certain distance to an object. In order to determine this distance, it
could be desirable to use the Euclidean distance which includes the
square root function ($\sqrt$). However, \pddl3.1 supports only four
arithmetic operators (=+=, =-=, =/=, =*=). These operators can be used
in preconditions, effects and durations.
\textcite{parkinson2012increasing} describe a workaround for this
drawback. By writing an action =calculate-sqrt=, they bypass the lack
of this function and rather write their own action that makes use of
the Babylonian root method. The square root can be approximated using
the Babylonian method, requiring many iterations, this method would
most likely have an adverse effect on plan generation
\cite{parkinson2012increasing}.

The \pddl/Clojure interface reads a problem file and extracts all
locations, defined in the =(:init ...)= code block. In Clojure, the
Euclidean distances between all locations are then calculated and
written back to an extended problem file.

The calculator works on any arity of the specified predicate, so that
locations could be specified one, two and three dimensionally and even
used in higher dimensions.

However, this workaround certainly has a major drawback, apart from
the time required to calculate possibly unused distances. If the
number of locations is $n$, the number of calculated distances is
$n^2$, because every location has a distance to every other location.
The calculated distances have to be stored in the \pddl problem file,
potentially requiring a lot of space. Therefore, a sensible next step
to extend \pddl would be to increase its mathematical expressivity
\cite{parkinson2012increasing}. One possibility would be to declare a
requirement =:math= that specifies further mathematical operations and
to extend \pddl in future versions.

#+CAPTION: Extract of the extended file /Gary's Huge Problem/
#+CAPTION: before using \mypddl-loc.
#+BEGIN_SRC text
  ...
  (:init (location home-gary 7 3)
         (location home-gisela 10 5)) 
  ...
#+END_SRC

#+CAPTION: After the application of \mypddl-loc, the calculated distances 
#+CAPTION: are inserted in the =(:init ...)= code block of a copy of the
#+CAPTION: problem file.
#+BEGIN_SRC text
 (:init
  (location home-gary 7 3)
  (location home-gisela 10 5)
  (distance home-gary home-gary 0.0)
  (distance home-gary home-gisela 3.6056)
  (distance home-gisela home-gary 3.6056)
  (distance home-gisela home-gisela 0.0))
#+END_SRC

** Type Diagram Generator (myPDDL-dia)
<<subsec:gen>>

TODO: Write something about visual cortex or diagrammatic reasoning \\
...furthermore, visual information can be transmitted more precisely
\cite{goolkasian2000pictures} and remembered better
\cite{nelson1976pictorial}. The diagrammatic representation of textual
information helps to quickly understand the connection of
hierarchically structured items \cite{storey2005use} and is supposed
to simplify the communication and collaboration between developers.

Object types play a major role in typed \pddl domains: they constrain
the types of arguments to predicates and determine the types of
parameters used in actions. In order to use and extend available
domains, a crucial part is understanding the involved types, their
hierarchy and identifying the constructs that make use of them.
However, this can be difficult by just reading the textual
representation of the hierarchy, so a diagram that displays this
hierarchy could be helpful.

Creating such a diagram manually each time a change is made can be
unnerving and costly in terms of time. An automatically created
graphical representation could save time and energy.

\mypddl-dia serves this purpose, by generating and displaying diagrams
by means of domain files. Figure [[img:auto-gen]] shows the generated
diagram from the /Hacker World/ in Chapter [[ch:basics]]. In the diagram,
types are represented with boxes, with every box consisting of two
parts:

- The header displays the name of the type.
- The lower part displays all predicates that use the corresponding
  type at least once as a parameter. The predicates are written just
  as they appear in the \pddl code.

Generalization relationships ("is a", e.g. "a laptop /is a/ computer")
express that every subtype is also an instance of the illustrated
super type. This relationship is indicated in the diagram with arrow
from the subtype (here: /laptop/) to the super type, where the arrow
head aims at the super type (here: /computer/).

#+CAPTION: The type diagram that was generated from the
#+CAPTION: /Hacker World/ in Chapter [[ch:basics]] using \mypddl-dia.
#+NAME: img:auto-gen
[[/home/pold/Documents/BA/org-ba/hacker-world/diagrams/png-diagram7.pdf]]


In order to create the diagram, \mypddl-dia makes use of the
\pddl/Clojure interface that extracts the =(:types ...)= block. Then,
using regular expressions, the extracted types get split into super
types and associated subtypes and stored in a Clojure hash-map.

Subsequently, the diagram is generated using dot from the Graphviz
package \cite{ellson2002graphviz}, a collection of programs for
drawing graphs. dot is a scriptable, graphing tool, that is able to
generate hierarchical drawings of directed graphs in a variety of
output formats (e.g. \textsc{png}, \textsc{pdf}, \textsc{svg}). The
input to dot are text files, written in the \textsc{dot} language.

Based on the Clojure representation, the description of a directed
graph in the \textsc{dot} language is created and saved in the folder
=dot/= that is located in the same folder as the \pddl domain file.
The \textsc{dot} file is then passed to dot, creating a \textsc{png}
diagram and saving it in the folder =diagrams/=. Additionally, the
diagram is immediately displayed in a window. Simultaneously, a copy
of the domain file is stored in the folder =domains/=. Every time
\mypddl-dia is invoked, these steps are executed and the names of the
saved files are extended by an ascending revision number. Thus, one
cannot only identify associated \pddl, \textsc{dot} and \textsc{png}
files, but also use this feature for basic revision control. Figure
\ref{fig:mypddl-new-project-folder} displays the folder structure
after invoking \mypddl-dia twice on the /Hacker World/. The type
hierarchy and predicate structure of a previous version of a domain
file can thereby be identified by the corresponding type diagram (both
files have matching revision numbers), and it is possible to revert to
a previous revision, stored in the folder =domains/= .

#+BEGIN_LATEX
\begin{figure}[] 
\dirtree{%
.1 hacker-world.pddl.
.2 dot.
.3 dot-diagram0.dot.
.3 dot-diagram1.dot.
.2 diagrams.
.3 png-diagram0.png.
.3 png-diagram1.png.
.2 domains.
.3 hacker-world0.pddl.
.3 hacker-world1.pddl.
}
\caption[\mypddl-dia folder structure]{\label{fig:mypddl-new-project-folder}
Folder structure after two invocations of \mypddl-dia.
Files and folders are automatically created and extended by a revision number
(\texttt{0},\texttt{1}) each time dia is used.}
\end{figure}
#+END_LATEX


** Integrated Design Environment (myPDDL-IDE) 

While \mypddl-snippet and -syntax are devised for Sublime Text, the
other tools (new, diagram, distance) can be used independently of the
editor by way of a command-line interface. This offers high
flexibility, the possible automation of jobs by using scripts, and the
possibility for integration into different software
\cite{dix2009human}. However, you might want to stick to Sublime Text
and write, plan, visualize and debug your \pddl files using a single
meta-tool.
 
\mypddl-IDE, the integrated development environment for \mypddl
combines the so far presented tools using Sublime Text [fn:26].

\mypddl can be installed automatically via Sublime Text Package
Control \cite{stpackage} or by copying the folder \mypddl [fn:8] into
the packages folder of Sublime Text [fn:7]. Subsequently, the features
can be activated by changing Sublime Text's syntax to \pddl
(\menu{View > Syntax > PDDL}).

Subsequently \mypddl can be invoked using the Sublime Text command
palette [fn:27], where available \mypddl commands are displayed and
the user can execute them using the mouse or the keyboard. It is
possible to choose from the following commands (TODO: Table xyz lists
the available commands with a description):

- /PDDL: Create Project/ :: Asks the user to specify a project name in
     the Sublime Text input panel and then creates a new \pddl project
     using \mypddl-new.
- /PDDL: Calculate Distances/ ::  Invokes the distance calculator
     \mypddl-distance for the currently opened \pddl problem. 
- /PDDL: Display Type Diagram/ :: Displays the type diagram of the
     currently opened \pddl domain. 

Thus, \mypddl-IDE provides a flexible framework for editing \pddl
files, where all the \pddl-independent features and extensions of
Sublime Text can be used [fn:28].

[fn:7] Further information about Sublime Text packages can be found at
http://www.sublimetext.com/docs/3/packages.html.

[fn:8] The files can be downloaded from https://github.com/Pold87/ba-thesis/.

[fn:21] Overview of Sublime Text features can be found at
http://www.sublimetext.com/docs/2/ and
http://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/.

[fn:27] Defaults to the shortcut \keys{\ctrl+\shift+P}.

[fn:28] A small overview of Sublime Text's features is given in
Chapter [[ch:related.]]


* Evaluation
<<ch:evaluation>>

To evaluate a software means to assess its quality. Appropriate
criteria are supplied by \textcite{shah2013knowledge} who evaluate
different knowledge engineering tools in planning including \itsimple.
All in all, they identified seven criteria, the lead questions of
which can be found in Table [[tab:criteria]].

#+CAPTION: The seven design criteria that were identified by \textcite{shah2013knowledge}
#+NAME: tab:criteria
| /Criteria/     | /Description/                                              |
|----------------+------------------------------------------------------------|
| Operationality | How efficient are models produced?                         |
|                | Is the method able to improve the performances of planners |
|                | on generated models and problems?                          |
| Collaboration  | Does the method/tool help in team efforts?                 |
|                | Is the method/tool suitable for being exploited in teams   |
|                | or is it focused on supporting the work of a single user?  |
| Maintenance    | How easy is it to come back and change a model?            |
|                | Is there any type of documentation that is automatically   |
|                | generated?                                                 |
|                | Does the tool induce users to produce documentation?       |
| Experience     | Is the method/tool indicated for inexperienced users?      |
|                | Do users need to have good knowledge of PDDL?              |
|                | Is it able to support users and to hide low level details? |
| Efficiency     | How quickly are acceptable models produced?                |
| Debugging      | Does the method/tool support debugging?                    |
|                | Does it down on the time needed to debug?                  |
|                | Is there any mechanism for promoting the overall quality   |
|                | of the model?                                              |
| Support        | Are there manuals available for using the method/tools?    |
|                | Is it easy to receive support?                             |
|                | Is there an active community using the tool?               |


The first criterion (/operationality/) was not of interest when
developing \mypddl, since it can be reduced to the question of whether
planners perform well on \pddl files created using a text editor
(instead of a graphical language). Therefore, it was decided to
replace the criterion /operationality/ with /functional suitability/
from the \textsc{isco/iec} 25010 standard. To assess the functional
suitability and to illustrate where \mypddl fits in with similar
tools, it was compared to the other three tools introduced and
discussed in chapter 3, namely \pddlstudio, \itsimple, and \pddlmode
for Emacs. Of the remaining six criteria in Table [[tab:criteria]],
/collaboration/, /experience/, and /debugging/ were tested with a
usability test. The other three criteria, /maintenance/, /efficiency/,
and /support/, will simply be discussed.


** Benchmarking

The comparison of \mypddl to the three tools from Chapter ch:related
is intended to to show its appropriateness or “the degree to which the
software product provides an appropriate set of functions for
specified tasks and user objectives“ (\textsc{iso} 25010 6.1.1). Where
does \mypddl fit in with existing tools for the same purpose? When and
for which tasks it is best suited? The major user objective is
identical for all four tools and can be summed up as the desire to
integrate human knowledge into a knowledge based system, in particular
to create domains and problems that can be fed to a planner. All tools
intend to support this process in general and the various stages of
the design cycle to different degrees. However, sometimes knowledge
engineers may only have to alter or develop already existing models
further. \mypddl aims to also assist with the objective to quickly
understand foreign code. Table [[tool-comp]] illustrates how the four
tools compare in terms of features and how each of these features is
helpful in the knowledge engineering process.


#+CAPTION: Comparison of tools and their features for creating domains.
#+NAME: tool-comp
#+ATTR_LATEX: :float sidewaystable :font \footnotesize
|                                     | Function                                              | \pddlstudio | \itsimple | \pddlmode | \mypddl |
|-------------------------------------+-------------------------------------------------------+-------------+-----------+-----------+---------|
| /                                   |                                                       | <           |           |           |         |
| latest supported \pddl version      | considering recent \pddl features                     | 1.2         | 3.1       | 2.2       | 3.1     |
| syntax highlighting                 | supporting error detection and navigation             | Yes         | Yes       | Yes       | Yes     |
| syntactic error detection           | supporting debugging                                  | Yes         | No        | No        | Yes     |
| automatic indentation               | supporting readability and navigation                 | No          | No        | Yes       | Yes     |
| semantic error detection            | supporting debugging                                  | Yes         | No        | No        | No      |
| code completion                     | speeding-up knowledge engineering process             | Yes         | No        | Yes       | Yes     |
| code snippets                       | speeding-up knowledge engineering process             | No          | Yes       | Yes       | Yes     |
|                                     | externalizing user's memory                           |             |           |           |         |
| code folding                        | supporting keeping an overview                        | Yes         | No        | Maybe     | Yes     |
| project management                  | supporting keeping an overview                        | Yes         | Yes       | No        | Yes     |
| \pddl code visualization            | supporting fast understanding                         |             |           |           |         |
| \uml to \pddl code translation      | supporting initial modeling                           | No          | Yes       | No        | Yes     |
| customization features              | acknowledging individual needs and preferences        |             |           |           |         |
| planner integration                 | allowing for easy planner access                      | Basic       | Yes       | No        | Yes?    |
| plan visualization                  | supports understanding and crosschecking the plan     | no          | yes       | no        | no      |
| Petri net visualization             | supporting dynamic domain analysis and model checking | no          | yes       | no        | no      |
| declaration menu                    | supporting easy code navigation                       | no          | no        | yes       | no      |
| interface with programming language | automating tasks                                      |             |           |           |         |
|                                     | extending \pddl's modeling capabilities               |             |           |           |         |
TODO!

** Usability Test

The nightmare of any system development group is spending years and
vast amounts of money on developing a system and finding, upon its
release, that users cannot interact with it properly or do not see how
it can help them. When designing and implementing a system intended to
support humans, it is therefore of great importance to determine its
usability \cite{johnson2000gui}. A common method for doing so is by
usability testing (inviting users to thoroughly test the software by
means of a series of realistic tasks and asking their opinions).
Therefore, two of the most important \mypddl features, syntax
highlighting and type diagram generation, were tested in a small user
study.

*** Participants

A total of eight participants (three female participants, average age
was 22.9, with a standard deviation of 0.6) took part in this
usability test [fn:13]. Eight subjects was the minimum possible in
this study in order to fully control for possible sequence and
learning effects. Also, it was ensured that all participants were
familiar with at least one Lisp dialect, so that no one would be
confused by program code written as parenthesized lists. None of the
participants had prior experience with planning in general or \pddl in
particular. Furthermore, none of them had used Sublime Text before.

[fn:13]  Small sample sizes are sometimes criticized even in usability
studies, because it is hard to detect issues that only few people
have. For example, the number of people that are affected by
hard-to-find information on vegan food served on a flight or by
hard-to-find information on luggage constraints differs. Therefore,
the latter will most likely be uncovered with small sample sizes,
while the former might not. Reviewing the scientific discussion on
this topic at this point is beyond the scope of this thesis, but
testing more than the common five participants
\cite{nielsen1994estimating,nielsen1990heuristic,virzi1992refining} is
in line with more recent research
\cite{faulkner2003beyond,hwang2010number}.

*** Material 

It was decided to conduct the experiment at the home of the
experimenter to have a more welcoming and relaxing atmosphere than in
a university laboratory. A 30-minute interactive video tutorial for
planning and \pddl was recorded to familiarize participants with the
topic [fn:1]. The tutorial made no reference to \mypddl. A second
three minute video introduction to the functionality of the syntax
highlighter (\mypddl-syn) and the usage of the type diagram generator
(\mypddl-dia) was recorded. A preliminary questionnaire was designed
to assess the prior experience with planning and Sublime Text. The
system usability scale \cite{brooke1996sus} was chosen as a post
questionnaire to measure participants’ attitudes concerning the two
tested tools. The participants completed the actual tasks on a laptop
computer (15.6 inch screen) with an additional screen (15.1 inch) for
displaying the type diagram and the code side by side. All tasks were
completed using the Sublime Text editor with the color scheme
/Monokai/ [fn:17]. The times that participants took to answer
questions were recorded using an online tool [fn:10] as this allowed
splitting the total time on task into smaller times for subtasks.
Furthermore, the recorded times could be downloaded directly as a
\textsc{csv} file. To test the syntax highlighting and the type
diagram generator, two different task types were needed. As a within
subjects design was considered most suited (to control for individual
differences within such a small sample), it was necessary to construct
two tasks, matched in difficulty, for each of these two types to
compare the effects of having the tools available. Subsequently,
domains and instructions were written for these four tasks. The two
tasks to test syntax highlighting presented the user with domains that
were 54 lines in length, consisted of 1605 characters and contained 17
errors each. Errors were distributed evenly throughout the domains and
were categorized into different types. The occurrence frequencies of
these types were matched across domains as well, to ensure equal
difficulty for both domains (see table [[tab:errors]] in the appendix). To
test the type diagram generator, two fictional domains with equally
complex type hierarchies consisting of non-words were designed (five
and six layers in depth, 20 and 21 types). The domains were also
matched in length and overall complexity (five and six predicates with
approximately the same distribution of arities, one action with four
predicates in the precondition and two and three predicates in the
effect). All questionnaires and task descriptions can be found in the
appendix. Lastly, participants were given pen and paper and a one page
summary (/cheat sheet/) of \pddl domain syntax (see appendix) to help
them solve tasks if they saw a need for it.

[fn:10] http://online-stopwatch.chronme.com

[fn:17] /Monokai/ is the default color scheme of Sublime Text. It has
a dark gray background.

*** Method

No earlier than 24 hours before the experiment was to take place,
participants received the web link to the tutorial and were thus given
the option to watch it in their own time if they felt so inclined.
This method was chosen, because it was important that participants
learn and understand the contents and this could be hindered by the
presence of the experimenter or the testing situation, depending on
the subject’s personality. Upon their arrival, participants were
handed a consent form and the preliminary questionnaire. If they had
already watched the tutorial, they were asked if they had any
questions concerning the tutorial and if they thought that they had
understood everything. Otherwise, they proceeded to do so. After
watching the tutorial, they were asked to complete the tasks in the
order specified in table [[tab:order]] in the appendix. Two factors were
varied: whether the participant had the tools available for the first
two tasks or for the second two tasks, and whether the participant
started with a debugging task or a type hierarchy task. Directly
before being given the tasks requiring the application of the tools,
the three minute video introduction was shown. For the debugging
tasks, participants were given six minutes [fn:12] to detect as many
of the errors as possible. They were asked to record each error in a
table (pen and paper) with the line number and a short comment and to
immediately correct the errors in the code if they knew how to, but
not to dwell on the correction otherwise. For the type hierarchy task,
participants were asked to answer five questions concerning the
domains, all of which could be facilitated with the type diagram
generator, but some of which still required looking in the code.
Participants were told, that they should not feel pressured to answer
quickly, but to not waste time either. Also they were asked to say
their answer out loud, as soon as it became evident to them. They were
not told that the time it took them to come up with an answer was
recorded, since this knowledge could have made them feel pressured and
thus led to more false answers. At the end of the usability test, they
were asked to evaluate the perceived usability of \mypddl using the
system usability scale.

[fn:1] http://www.youtube.com/playlist?list=PL3CZzLUZuiIMWEfJxy-G6OxYVzUrvjwuVb

[fn:12] A reasonable time frame tested on two pilots.

*** Results
**** Debugging Tasks

To test the syntax highlighter, participants were asked to find as
many errors as they could in a given domain within a certain amount of
time. On average, participants found 7.6 errors without syntax
highlighting and 10.3 errors with syntax highlighting (i.e.
approximately 35 % more errors were found with syntax highlighting). The
difference is shown in Figure \ref{fig:found-errors-combined}.

#+BEGIN_LaTeX
    \begin{figure}[h]
      \centering
      \hspace{0.5cm}
      \includegraphics[width=0.6\textwidth]{found-combined.pdf}
      \caption{Comparison of detected errors with and without the syntax
        highlighting feature. Each cross ($\times$) shows the data value
        of one participant. The bars display the arithmetic mean.}
    \label{fig:found-errors-combined}
    \end{figure}
#+END_LaTeX

Here, it is worth considering the comments and remarks made by the
participants during testing. Two participants (participants 5 and 6)
remarked that the syntax highlighting colors confused them and that
they found them more distracting than helpful. One of them even
mentioned that the contrast of the colors used was so low that they
were hard for her to distinguish. She found the same number of errors
with and without syntax highlighting, the other of the two was the
only participant that found less errors with syntax highlighting than
without it. Excluding these two participants from the analysis results
in 49\nbsp% more errors being found with the help of syntax
highlighting. Since only eight participants took part in the study,
splitting the data up further (to compare, for example, the errors
found per domain) did not appear sensible as aggregated data values
would then consist of data from four participants at the most. A
between groups comparison with only four individuals per group is most
likely not going to provide insightful and reliable results (TODO:
source).

**** Type Hierarchy Tasks

Figure \ref{fig:task-completions-agg} shows the geometric mean [fn:23]
of the task completion time [fn:22] for each question with and without
the type diagram generator.

#+BEGIN_LaTeX
  \begin{figure}[h]
    \centering
    \hspace{0.5cm}
    \includegraphics[width=0.6\textwidth]{task-completions-agg.pdf}
    \caption{The diagram shows the geometric mean of the task completion time.
             The crosses ($\times$) represent one participant.
The percent values at the bottom of the bars display the completion rate, i.e.
what percentage of users completed this task successfully.}
    \label{fig:task-completions-agg}
  \end{figure}
#+END_LaTeX

It can be seen that when having the type diagram generator available,
participants answer all questions, except Question 4, on average
nearly twice as fast. The fact that the availability of tools did not
have a positive effect on task completion times for Question 4 can
probably be attributed to the complexity of this question. In contrast
to the other four questions, to answer Question 4 correctly, the
participants were required to look at the actions in the domain file
in addition to the type diagram. Most participants were confused by
this, because they had assumed that once having the type diagram
available, it alone would suffice to answer all questions. This
initial confusion cost some time, thus negatively influencing the time
on task. Therefore, Question 4 is excluded from Diagram
\ref{fig:task-completions-agg-without-q4}.

#+BEGIN_LaTeX
  \begin{figure}[h]
    \centering
    \hspace{0.5cm}
    \includegraphics[width=0.6\textwidth]{ttot1.pdf}
    \caption{Geometric mean of the total time on task without Question 4.}
    \label{fig:task-completions-agg-without-q4}
  \end{figure}
#+END_LaTeX

Diagram \ref{fig:task-completions-agg-without-q4} illustrates the
effect that the tool availability had on the total time participants
spent on a task, without question 4. It only takes 52% of the time
without tools to answer questions 1, 2, 3 and 5 once tools can be
used.

[fn:22] The task completion time only includes task times of users who
completed the task successfully.

[fn:23] The geometric mean is a more accurate measure of the mean for
small sample sizes as task times have a strong tendency to be positively
skewed \cite{sauro2012quantifying}. 

**** System Usability Scale

\mypddl reached a score of 89.6 on the system usability scale [fn:24],
with a standard deviation of 3.9. Figure \ref{fig:sus} displays this
score and the data values of the seven participants who completed this
questionnaire. Since the overall mean score of the system usability
scale is approximately 68 with a standard deviation of 12.5
\cite{sauro2011practical}, the score of \mypddl is well above average
with a small standard deviation. A score of 89.6 is usually assigned
to superior products \cite{bangor2008empirical}. Furthermore, 89.6
corresponds approximately to a percentile rank of 99.8 %, meaning that
it has a better perceived ease-of-use than 99.8 % of the products in
the database used in \textcite{sauro2011practical}.

#+BEGIN_LaTeX
  \begin{figure}[]
    \centering
    \hspace{0.5cm}
    \includegraphics[width=0.6\textwidth]{sus1.pdf}
    \caption{\mypddl got a score of 89.6 on the system usability scale
      that ranges from 0 - 100. Every cross ($\times$) indicates the
      system usability scale value of one participant. It is evident
      that all scores range in the high end of the scale.}
    \label{fig:sus}
  \end{figure}
#+END_LaTeX


[fn:24] The range of possible values for the system usability scale is
0 to 100.


** Discussion

Although participants’ responses in the System Usability Scale seem to
indicate that myPDDL is an enjoyable software with a high usability,
it is still necessary that it is evaluated with regard to the afore
mentioned criteria in order to reach an informed conclusion concerning
its quality.

**** Functional Suitability

When comparing the feature diversity of \mypddl with that of other
tools for the same purpose, it becomes immediately evident that
\mypddl is not only up to par, but, integrated into Sublime Text, it
provides a rich developing environment for \pddl files. One of its
strengths lies in being up-to-date and supporting the most recent
\pddl version. Due to the Sublime Text integration, it also offers all
basic editor features and a high customizability. Being the only one
of the four tools capable of visualizing parts of the \pddl code, it
must be understood as complementary to \itsimple, which takes the
opposite approach of transforming \textsc{uml} diagrams into \pddl
files. The fact that \mypddl does not check for semantic errors is not
actually a drawback, as planners will usually detect semantic errors.
All in all, \mypddl combines the most useful tools of \pddlstudio,
\itsimple and \pddlmode for Emacs and strives to support the knowledge
engineer during all phases of the modeling process. Additionally, it
features some unique tools, which have, in part, already been proven
to be helpful in the user study. It can therefore be concluded that
\mypddl provides an appropriate set of functions for developing \pddl
files and is thus functionally suitable.

**** Collaboration

With the growing importance of team work and team members not
necessarily working in the same building or in the same country for
that matter, there is an increasing need for tools supporting the
collaboration effort. In developing \mypddl, this need was sought to
be met by \mypddl-dia. Complex type hierarchies can be hard to
overlook, especially if they were constructed by someone else.
Therefore, a good way of tackling this problem seemed to be by
providing a means to visualize such hierarchies in the form of type
diagrams. But is this really able to help knowledge engineers? This
was tested in the user study by having participants answer questions
on complex type hierarchies that they had never seen before, made up
entirely of non-words (to eliminate the interference of world
knowledge). With the help of the diagram participants were able to
answer questions correctly nearly twice as fast as without this
service. This indicates that \mypddl-gen helps to understand foreign
domain structures faster and more easily, therefore facilitating the
collaboration between knowledge engineers.

**** Experience

Although it is assumed that most people interested in using \mypddl
have some experience in planning, unversed users should not be put off
by a complex or incomprehensible interface. To test if \mypddl is
usable even for novices, it was chosen to only allow for inexperienced
participants in the user study. However they were all required to be
familiar with at least one Lisp dialect because \pddl is Lisp-based.
As described above, participants were asked to watch a 30-minute
interactive planning and \pddl video tutorial, establishing the
basics. Before having to use the \mypddl tools, another three minute
video tutorial introduced \mypddl-syn and \mypddl-dia. None of the
users seemed to have any problems in comprehending either of these
tools after seeing the tutorial. Therefore, it can be concluded that a
small time investment for inexperienced users, and an possibly even
smaller investment for \pddl experts, results in proficient usage of
\mypddl. Nonetheless, two subjects reported having trouble with
\mypddl-syn, because they did not find it helpful or because they
found the colors hard to distinguish. It seems, though, that this
cannot be accounted to inexperience so much as to personal preference.

**** Debugging

To help users find errors faster, the syntax highlighting feature
\mypddl-syn was created. It highlights all syntactically correct
constructs and leaves all syntactical errors non-highlighted. In order
to assess if \mypddl helps in debugging, \mypddl-syn was included in
the usability test. Users were asked to find as many errors as they
could in a specified amount of time. Six of the eight subjects found
more errors with syntax highlighting than without it, one person found
the same number and one actually found one error less with the tool
available. These latter two users reported being distracted by the
colors. Syntax highlighting is optional in the Sublime Text
integration, thanks to the high customizability, and what is more,
different color schemes allow for the individualization of
\mypddl-syn. However, this option was not made available in the user
study, as it would have been an additional, possibly confounding
variable, making the results harder to interpret. While eight people
seem too few to generalize the numbers, it can be said that \mypddl
with \mypddl-syn seems to help the majority of users in debugging.


**** Maintenance

The possibility to maintain \pddl files is a key aspect of \mypddl.
The automatically generated type diagram (\mypddl-dia) gives an
overview of the domain structure, and thereby serves as a continuous
means of documentation. In addition, the diagram supports the
understanding of existing or extended domains provided by other
knowledge engineers. Helping to understand foreign code, though, it
follows logically that \mypddl-dia also helps in coming back and
changing one’s own models if some time has elapsed since they were
last edited. The basic revision control feature of \mypddl-dia keeps
track of changes, making it easy to revert to a previous domain
version. Furthermore, \mypddl-new encourages adhering to an organized
project structure and stores corresponding files at the same location.
Text-based modeling facilitates using a common revision control system
like Git \cite{gronniger2007textbased}. The automatically created
readme file can induce the user to provide further information and
documentation about the \pddl project. When using a web-based hosting
service, the readme file is usually prominently displayed on the home
page of the project.


**** Efficiency

All \mypddl tools are intended to increase the efficiency with which
\pddl files are made. For one, code snippets enable the fast creation
of large and correct code skeletons that only still need to be filled
in. While the type diagram generator facilitates collaboration, it can
also be used to double check if the type hierarchy and the predicates
that use the types have been implemented as intended. Syntax
highlighting can reduce the time spent on searching errors. Code
folding allows users to hide currently irrelevant parts of the code
and automatic indentation increases its legibility. To easily keep
track of all the parts of a project, folders are automatically created
and named. Lastly, it is also possible to customize \mypddl so as to
adapt its look and feel to other programs one is already familiar
with, or simply to make it more enjoyable to use. All these features
should increase the efficiency, and especially skilled knowledge
engineers should be able to produce acceptable models very quickly
with the help of \mypddl.

**** Support

\mypddl can be installed using Sublime Text's Package Control
\cite{stpackage}. This allows for an easy installation and staying
up-to-date with future versions. In order to provide global access and
with it the possibility for developing an active community, the
project source code is hosted on GitHub [fn:19]. An additional project
site [fn:20] provides \mypddl video introductions, a manual and room
for discussing features and reporting bugs.


#+BEGIN_LaTeX
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{found-errors-splitted.pdf}
\caption[]{\label{fig:planet-splisus}The Domain Planet Splisus.}
  \end{figure}
#+END_LaTeX

[fn:19] https://github.com/Pold87/myPDDL

[fn:20] http://pold87.github.io/sublime-pddl/

* Conclusion and Future Work
<<ch:conclusion>>


\mypddl has been designed to support knowledge engineers in modeling
planning task specifications as well as in understanding, modifying,
extending and using existing planning domains. Implemented features
that are made available in the Sublime Text editor comprise code
editing features, namely syntax highlighting and code snippets, a type
diagram generator and a distance calculator. 

A faster understanding of the domain structure could be beneficial for
the maintenance and application of existing domains and problems, and,
possibly for the communication between engineers.


Different needs and requirements of different knowledge engineers were
met by the modular, extensible and customizable architecture of the
toolkit. Knowledge engineers can customize and extend Sublime Text and
use existing text editor features. \mypddl is written in a modular
fashion, and is highly customizable. Although \mypddl is made
available in Sublime Text, users could transfer the ideas to other
text editors.

The user study shows some initial evidence that the core features,
syntax highlighting (\mypddl-sub) and type diagram generation
(\mypddl-dia) can support knowledge engineers in the design and
analysis process, in particular in error detection and in keeping
track of the structure of a \pddl domain and argue for a very high
usability.




The modules of this thesis point to several interesting directions The
\pddlq/Clojure interface provides a basis for dynamic and interactive
planning scenarios. So, time-dependent knowledge could be modeled by
adding facts (learning) to and retracting facts (forget) from facts a
\pddl file.


Another alternative is to make use of an external helper and, instead
of calculating every entry of the distance matrix. the distance only
if needed, incorporate every possible combination of two locations.


Can be shifted toward real world problems in order to solve ... your
recurrent problem of Chapter 1.


\printbibheading
\printbibliography[nottype=online,heading=subbibliography,title=Paper Sources]
\printbibliography[type=online (\, heading=subbibliography) (\, title=Website) Sources]
* Export Configuration                                     :ARCHIVE:noexport:
#+TITLE:  My\textsc{pddl} - A Modular Knowledge Engineering System for the Planning Domain Definition Language
#+AUTHOR: Volker Strobel
#+EMAIL: volker.strobel87@gmail.com
#+HTML: <div class="container">
#+LANGUAGE: en
#+OPTIONS: toc:t todo:nil
#+LATEX_CLASS: report
#+LaTeX_CLASS_OPTIONS: [a4paper,12pt]
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage[bibstyle=numeric,citestyle=numeric,backend=biber]{biblatex}
#+LaTeX_HEADER: \addbibresource{bibliography.bib}
#+LaTeX_HEADER: \usepackage[]{hyperref}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{rotating}
##+LaTeX_HEADER: \usepackage[]{keystroke}
#+LaTeX_HEADER: \hypersetup{hidelinks}
##+LATEX_HEADER: \usepackage{fontspec}
##+LATEX_HEADER: \usepackage{libertineotf}
#+LaTeX_HEADER: \usepackage[]{nomencl}
#+LaTeX_HEADER: \usepackage{svg}
#+LaTeX_HEADER: \usepackage{xspace}
#+LaTeX_HEADER: \usepackage{dirtree}
#+LaTeX_HEADER: \usepackage[autostyle]{csquotes} 
#+LaTeX_HEADER: \definecolor{dhscodebg}{rgb}{0.95,0.95,0.95}
#+LaTeX_HEADER: \usepackage{menukeys}
#+LATEX_HEADER: \usepackage{scalefnt}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{lscape}
#+LATEX_HEADER: \usepackage{rotating}
#+LATEX_HEADER: \usepackage{epstopdf}

##+LaTeX_HEADER:% \newcommand{\mypddl}{\textsc{myPddl}\xspace}
#+LaTeX_HEADER: \newcommand{\mypddl}{\smallerft[0.8]{myPDDL}\xspace}
#+LaTeX_HEADER: \newcommand{\pddlstudio}{\textsc{pddl studio}\xspace}
#+LaTeX_HEADER: \newcommand{\itsimple}{\textsc{itSimple}\xspace}
#+LaTeX_HEADER: \newcommand{\pddlmode}{\textsc{pddl}-mode\xspace}
#+LaTeX_HEADER: \newcommand{\pddl}{\textsc{pddl}\xspace}
#+LaTeX_HEADER: \newcommand{\uml}{\textsc{uml}\xspace}
#+LATEX_HEADER: \newcommand\smallerft[2][0.85]{{\scalefont{#1}#2}}

#+PROPERTY: tangle hacker-world-tangle.pdl
#+OPTIONS org-export-publishing-directory "./exports"
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/bootstrap.css" />
** TODO: Glossary?
   
