#+LATEX_CLASS: article
#+OPTIONS: author:nil toc:nil num:nil
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[margin=1.2in]{geometry}
#+LaTeX_HEADER: \usepackage[]{keystroke}
#+LaTeX_HEADER: \pagenumbering{gobble}
#+LATEX_HEADER: \usepackage[ngerman]{babel}
#+LANGUAGE: de
#+TITLE:Skript für PDDL-Tutorial 
#+DATE: 

* Einführung
Dieses Videotutorial soll in das Thema Planung und vorallem in die
Planungssprache PDDL einführen. Planung ist eine der wichtigsten
Komponenten des Problemlösens. Ein Problem liegt dann vor, wenn der
Soll-zustand nicht dem Ist-zustand entspricht. Bei der Planung wird
eine Abfolge von Handlungsschritten entworfen, die vom Ist-Zustand zum
Soll-Zustand führt. D.h. es wird ein Plan wird erstellt, der das
Problem löst. Ziel der künstlichen Intelligenz Forschung ist es
natürlich, dass die Planung von der künstlichen Intelligenz ausgeführt
wird. Damit dies erfolgen kann, ist eine detaillierte Beschreibung der
Umwelt und des Problems notwendig. Ausserdem bedarf es eines
Algorithmus, der aus diesen Beschreibungen die nötigen Schritte
herleiten kann, die zur Lösung des Problems führen. Die drei
Bestandteile der automatisierten Planung sind also:

#+CAPTION: Planung in der KI
#+ATTR_LaTeX: \footnotesize
** Planung – Künstliche Intelligenz			
|   | *Komponente* | *Domain*                    | *Problem*            | *Planner*       |
|---+--------------+-----------------------------+----------------------+-----------------|
| / |      >       |             >               |           >          |        >        |
|   | *Definition* | Beschreibung                | Beschreibung         | Software zur    |
|   |              | der Welt                    | des Problems         | Generierung des |
|   |              |                             |                      | Plans           |
|   | *Inhalt*     | -  Eigenschaften und        | - Instanziierung von | Algorithmus     |
|   |              | Beziehungen von Typen       | Objekten             |                 |
|   |              | - Aktionen und Konsequenzen | - /Ist/-Zustand      |                 |
|   |              |                             | - /Soll/-Zustand     |                 |
|   | *Umsetzung*  | PDDL                        | PDDL                 | Programm        |
|   | *Ausführung* | Mensch                      | Mensch               | KI              |
|   |              |                             |                      |                 |




Die Domäne und das Problem müssen zunächst erstellt werden, bevor sie
dem Planer übergeben werden können. Dieses Modellieren wird heutzutage
noch hauptsächlich von menschlichen Experten vorgenommen. Daher bedarf
eines Formulierungsstandards, der durch Planungssprachen gewährleistet
wird. Analog zu Programmiersprachen haben diese eine Syntax, also
konkrete Regeln und Vorschriften zum Erstellen von Domänen und
Problemen. Eine dieser Planungssprachen ist die Planning Domain
Definition Language oder PDDL. 

Im Folgenden soll dir nun beigebracht werden wie man mit PDDL Domänen
aufbaut. Dies wird anhand von einem konkreten Beispiel geschehen und
nach jedem Schritt wird dir eine Verständnisfrage gestellt. Du kannst
das Tutorial jederzeit pausieren um Fragen zu stellen, nochmal über
etwas nachzudenken oder zurückspulen wenn du etwas nochmal anschauen
möchtest. Versuche vorallem die Konzepte zu verstehen, damit du später
selbst Domänen erstellen kannst. Es ist nicht von Bedeutung, dass du
die Programmgerüste oder programmspezifischen Begriffe auswendig
lernst, jedoch, dass du sie später verstehst, wenn du sie erneut
siehst.

* Beispiel
** Die Welt
Unsere Welt besteht aus zwei Menschen: Tyler und Marla und dem Roboter
Robbie. Tyler arbeitet im Büro einer Autofirma und Marla studiert
Psychologie an der Uni Tübingen. Tyler und Marla können sich in
verschiedenen Räumen aufhalten. Es gibt eine Küche, ein Bad, zwei
Schlafzimmer, ein Wohnzimmer und eine Garage. Außerdem haben sowohl
Tyler (VW Polo) als auch Marla (Ford Mustang) ein Auto, aber Marla hat
zusätzlich noch ein pinkes Fahrrad. Alle Fahrzeuge stehen in der
Garage. Marlas Auto ist aber leider gerade kaputt.

** Das Problem
/Ist/: Tyler und Marla sind zu Hause. \\
/Soll/: Tyler soll auf die Arbeit und Marla soll zur Uni.

** Aufbau einer Domäne
Wie können wir das Ganze jetzt in PDDL repräsentieren?
Wir brauchen also eine Domain-Datei und eine Problemdatei. Wie gesagt
werden in der Domain abstraktive Typen deklariert, die dann in der
Problemdatei instanziiert werden, d.h. es werden manche Elemente aus
der Beschreibung der Welt erst in der Problemdatei konkretisiert. Was
das aber genau heißt, werden wir gleich sehen. Wir werden uns jetzt im
Folgenden dem Aufbau einer Domain widmen.

Domains in PDDL haben die folgende Form:

#+BEGIN_EXAMPLE
(define (domain name)
  
  (:requirements :requirement1
 		 :requirement2...)
  
  (:types  subsubtype1 subsubtype2 – subtype1
           subtype1 – type1
           subtype2 – type2
           ...
           type1 type2 ...  - object)

  (:predicates  (predicateName1 ?var1 – type-of-var1)
                (predicateName2 ?v1 – type-of-v1 ?v2 – type-of-v2)
                ...)

  (:action action-name-1
     :parameters (...)
     :precondition (...)
     :effect (...) )

  (:action action-name-2
    :parameters (...)
    :precondition (...)
    :effect (...) )
...)
#+END_EXAMPLE

Das wollen wir nun absatzweise anschauen und aufbauen. Wichtig ist zu
wissen, dass in einer Domäne immer nur eine abstrakte Repräsentation
der Welt modelliert wird, die konkrete Ausgestaltung erfolgt dann in
der Problemdatei. Aber was das genau heißt, siehst du gleich.

** Domain (define (domain name) ...)
Da du schon in LISP oder abgeleiteten Programmiersprachen programmiert
haben solltest, sollte dir die Klammerung vertraut vorkommen. Als
nächstes wird eingeklammert was man eigentlich in dieser Datei
definieren möchte. Dazu muss man sich als erstes entscheiden ob man
eine Domäne oder ein Problem modellieren will. Wir interessieren uns
momentan nur für Domänen, weshalb das erste Wort immer =domain= sein
wird. Jetzt kann man einen Namen für die Domäne festlegen. Dieser kann
frei gewählt werden. Da die Hauptakteure unserer Welt Tyler und Marla
heißen, nennen wir unsere Domäne fightclub. Bisher sieht unsere
PDDL-Datei also so aus:

#+BEGIN_EXAMPLE
(define (domain fightclub)
#+END_EXAMPLE

** Requirements (:requirements ...)

Hier werden Domäneneigentschaften festgelegt. Unsere Domänen haben nur
ein =requirement=, nämlich =:typing=. Das heißt, dass es in unseren
Welten Typenhierarchien gibt. Alle weiteren möglichen Requirements
sollen uns nicht interessieren. Die Domäne sieht also jetzt so aus:

#+BEGIN_EXAMPLE
(define (domain fightclub)
  (:requirements :typing) 
#+END_EXAMPLE

** Types (:types ...)
 In diesem Absatz wird die Welt typisiert, bzw. strukturiert. Alle
Entitäten in Domänen sind immer vom Typ =object=. Innerhalb dieser
Objektoberklasse gibt es dann verschiedene Typen und Untertypen. Die
Hierarchien werden im Absatz (types ...) modelliert. Damit wir nichts
vergessen, ist es sinnvoll uns zunächst den Aufbau unserer
Beispielwelt in Form eines Diagramms zu veranschaulichen. \\

/(Diagramm zeichnen)/ \\

\\

**** PDDL-Umsetzung

#+BEGIN_EXAMPLE
(:types agent location vehicle - object
        human robot - agent
        man woman - human
        office university room - location
        kitchen bathroom bedroom livingroom garage - room
        car bike - vehicle)
#+END_EXAMPLE

**** /Gestrichen/ \\
Zur Überprüfung ob du das verstanden hast, versuche nun bitte folgende
Hierarchie selbst umzusetzen. Male hierfür zunächst auch ein
UML-Diagramm.


In einer Firma gibt es verschiedene Hierarchieebenen. Ausschließlich
Agenten können bei einer Firma arbeiten. Agenten können entweder
Roboter oder Menschen sein. Während es bei den Menschen
Hierarchiestrukturen gibt, ist dies bei den Robotern nicht der Fall.
Roboter haben keine Chefs und sind auch nicht in Führungspositionen,
sie tun einfach das wofür sie programmiert wurden. Die
Firmenhierarchie ist wie folgt: an oberster Stelle ist der Vorstand.
Neben dem Vorstand gibt es noch den Aufsichtsrat, der ebenfalls nur
aus Menschen besteht. Dem Vorstand ist alles untergeordnet. Auf der
nächsten Ebene lässt sich die Firma nun in die drei Bereiche
Entwicklung, Fertigung und Verkauf einteilen. Diese sind jeweils
wieder in zwei Abteilungen unterteilt, außer der Verkauf, der nur aus
5 einzelnen Arbeitern besteht (einzelne Arbeiter müssen nicht
modelliert werden). Jede Abteilung besteht wiederum aus zwei kleineren
Gruppen.

** Predicates (:predicates ...)
Objekte können in verschiedenen Zuständen existieren die Zustände
können sich ändern und miteinander in Beziehung stehen. So sind manche
Menschen gespaltene Persönlichkeiten und andere nicht, während einige
Männer sich gerne prügeln und Menschen befinden sich meistens auch an
einem bestimtten Ort. Um solche Zustände und Eigenschaften von
Objekten repräsentieren zu können gibt es Prädikate. Prädikate können
entweder wahr oder falsch sein. Außerdem unterscheidet man Prädikate
nach ihrer Stelligkeit. Wir wollen uns hier nur mit ein- und
zweistelligen Prädikaten befassen. Ein Prädikat ist einstellig, wenn
es nur ein Parameter gibt. Die Eigenschaft eine "Gespaltene
Persönlichkeit" zu sein, kann durch ein einstelliges Prädikat
modelliert werden. Das Prädikat könnte heißen dissociated und es hat
nur einen Parameter, nämlich ein Objekt vom Typen =human=. In
PDDL-Notation sähe das dann so aus: =(dissociated ?h – human)= Wobei
=?x= den Parameter ersetzt und festgelegt werden muss von welchem Typ
dieser sein soll. Variablennamen müssen mit einem '?' Anfangen,
gefolgt von einem Buchstaben. Danach können weitere Buchstaben folgen,
Zahlen Bindestriche oder Unterstriche. Groß – und Kleinschreibung in
PDDL spielt keine Rolle. Analog wollen wir für unsere Beispielwelt
folgende Prädikate definieren:


1. Objekte können an einer Location sein
2. Menschen brauchen einen Schlüssel um ein Fahrzeug zu benutzen
3. Fahrzeuge können kaputt sein

/Versuche einmal selbst diese Prädikate in PDDL-Notation
aufzustellen./

#+BEGIN_EXAMPLE
(:predicates (at ?l - location ?o - object)
             (key-for ?v - vehicle ?h - human)
             (broken ?v - vehicle))

#+END_EXAMPLE


** Absatz 5: Aktionen (:action  ...)
Zu guter Letzt wollen wir uns nun den Aktionen widmen. Aktionen
sind wichtig, da durch Aktionen die Zustände und Eigenschaften von
Objekten derart verändert werden können, dass Probleme gelöst werden
können. Aktionen bestehen immer aus drei Teilen: Parametern,
Vorbedingungen und Wirkungen.


Wir wollen eine Aktion, bei der ein Fahrzeug zerstört werden kann.

Als Vorbedingung soll gelten, dass sich der Zerstörer (Agent) und das
Fahrzeug an der gleichen Location befinden.

#+BEGIN_EXAMPLE
(:action destroy-vehicle
  :parameters (?v - vehicle ?a - agent ?l - location)
  :precondition (and (at ?l ?v)
                     (at ?l ?h))
  :effect (broken ?v))
#+END_EXAMPLE


Versuche nun einmal die Aktion drive für unsere Beispielwelt
aufzustellen, bei der eine Person ihren Ort ändert mittels eines
Fahrzeugs, das nicht kaputt sein darf, der Person gehören muss und im
selben Gebäude wie die Person zu Beginn sein muss (und sich
anschließend nicht an zwei Orten gleichzeitig befinden).

#+BEGIN_EXAMPLE
(:action drive
  :parameters (?h - human ?v - vehicle ?from ?to - location)
  :precondition (and (key-for ?v ?h)
                     (not (broken ?v))
                     (at ?from ?v)
                     (at ?from ?h))
  :effect (and (at ?to ?h)
               (not (at ?from ?h))
               (at ?to ?v)
               (not (at ?from ?v)))))
#+END_EXAMPLE

Herzlichen Glückwunsch!

