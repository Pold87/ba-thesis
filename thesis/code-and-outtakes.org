* Class Diagram Generator Code

The code is written in Clojure, a LISP dialect. As PDDL has a
'LISP-like syntax', using a LISP dialect for the interface is
convenient. This thesis uses Clojure[TODO: src], a relatively modern
LISP dialect that runs on the Java Virtual Machine. 

In order to start the document, a namespace has to be defined. The
required packages are:
- clojure.tools.reader.edn :: Safe file input. I will use this
  method for entirely replacing the tools in clojure.core/read
- clojure.java.io :: Methods for file input and output (IO)

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
  (ns org-ba.core
    (:gen-class)
    (require [clojure.tools.reader.edn :as edn]
             [clojure.java.io :as io]
             [clojure.pprint :as pprint]
             [speech-synthesis.say :as say]
             [speech-recognition.hear :as hear]))
#+END_SRC

#+RESULTS:
: ;; FileNotFoundException Could not locate clojure/data/json__init.class or clojure/data/json.clj on classpath:   clojure.lang.RT.load (RT.java:443)

#+RESULTS:
: #'user/a

As PDDL files and 'information' will be in stored externally, a reader
method is needed. Edn reader provides functionality and guarantees
that no harmful commands can be read in through the reader
interface.

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defn read-lispstyle-edn
  "Read one s-expression from a file"
  [filename]
  (with-open [rdr (java.io.PushbackReader. (clojure.java.io/reader filename))]
    (edn/read rdr)))
#+END_SRC

#+RESULTS:
: ;; CompilerException java.lang.RuntimeException: No such namespace: edn, compiling:(/tmp/form-init8614017276071820586.clj:5:5) 

Next, a macro is provided for writing to files. It rebinds *out* to a
writer (that open a file for writing). Therefore, print statements
(print, prn, etc.) that normally would be send to the standard out,
are redirected to the file.

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defmacro write->file
  "Writes body to the given file name"
  [filename & body]
  `(with-open [w# (writer ~filename)]
     (binding [*out* w#]
       ~@body))
  (println "Written to file: " ~filename))
#+END_SRC

#+RESULTS:
: ;;=> #'user/write->file

Desired objects that belong to a type for a domain are sometimes
provided in a plain list, like the following:

#+BEGIN_EXAMPLE
vw-passat
opel-corsa
chevrolet-volt
#+END_EXAMPLE

It would be convenient to add a type to these objects, for two
reasons:
- Add a super-type to the subtypes in the list
- Add a type to a list of objects for the problem file

The following method affords that:
#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defn read-objs
  "Read PDDL objects from a file and add type
  (e.g. 'table bed' -> (list table - furniture
                        bed - furniture))"
  [file object-type]
  (as-> (slurp file) objs
        (clojure.string/split objs #"\s")
        (map #(str % " - " object-type) objs)))
#+END_SRC

#+RESULTS:
: ;;=> #'user/read-objs

By the help of these methods, you can create PDDL templates, for
example for a domain file:

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj

(defn create-pddl
  "Creates a PDDL file from a list of objects and locations"
  [objs-file objs-type]
  (str
"(define (domain domainName)

  (:requirements
     :durative-actions
     :equality
     :negative-preconditions
     :numeric-fluents
     :object-fluents
     :typing)

  (:types\n"
   (pprint/cl-format nil "~{~&~5@T~a~}" (read-objs objs-file objs-type))
        ")

  (:constants

  )

  (:predicates

  )

  (:functions

  )

  (:durative-action actionName
     :parameters (?x - <objectType>)
     :duration (= ?duration #duration)
     :condition (at start <effects>)
     :effect (at end <effects>))
)"
))
#+END_SRC

#+RESULTS:
: ;; CompilerException java.lang.RuntimeException: No such namespace: pprint, compiling:(/tmp/form-init8614017276071820586.clj:17:4) 

PDDL widely supports 'types'. These define possible shapes for objects
(similar to 'classes' in object oriented programming (OOP)). Types are
defined in the ':types' section of the PDDL domain file:
#+BEGIN_EXAMPLE
....
(:types man woman - human
        human - agent
        robot - agent)
...
#+END_EXAMPLE

A meaning-full type hierarchy is the basis for clean, well-written
domains. Type definitions constitute the first part in the PDDL
domain design process, as they determine, on which possible objects
actions can be performed. 

In order to further work with the specified types, they have to be
extracted from the PDDL file. For this task, a regular expression is
used, that splits the types in subtypes and belonging types.

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defn split-up
  "Split a PDDL type list (:types obj1.1 obj1.2 - objT1 obj2 - objT2 ...)
  into strings of subtypes and associated types,
  [[subytype1 subtype 2 ... - type][subtype1 subtype2 ...][type]"
  [coll]
  (let [coll (if (= :types (first coll))
                 (rest coll)
                 coll)]
    ;; REVIEW: insert (\w) for trimming?
  (re-seq #"((?:\s*\w+\s*)+)-\s*(\w+)\s*"
        (clojure.string/join " " coll))))
#+END_SRC

#+RESULTS:
: ;;=> #'user/split-up

The resulting list can be used for creating a hash-map, where every
type from the PDDL type declaration is the hash-key and the subtypes
are the values. 

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defn types->hash-map
  "Convert splitted type list (['<expr>' '<subtype1.1> <subtype1.2> ...' '<type1>']
  to a hash-map {'<type1>': ['<subtype1.1>' '<subtype1.2>' ...], '<type2>': ...}"
  [coll]
  (reduce (fn [h-map [_ objs obj-type]]
           (let [key-obj-type (keyword obj-type)
                 existing-vals (key-obj-type h-map)]
          (assoc h-map
                 key-obj-type
                 (concat existing-vals
                       (clojure.string/split objs #"\s")))))
          {}
          coll))
#+END_SRC

#+RESULTS:
: ;;=> #'user/types->hash-map

Now, as these information is present in a 'native' Clojure data
structure, it can be used for various purposes. A desirable purpose
would be to display the type hierarchy in kind of a 'class' diagram:

#+name: map-entry->TikZ-seq
#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
(defn map-entry->TikZ-seq
  "Converts a hashmap entry (:key [val1 val2 ...])
to a TikZ string (key -- { val1, val2 })"
  [entry]
(str
 (name (key entry))
        " -- "
        "{" (clojure.string/join ", " (val entry)) "}"))
#+END_SRC

#+RESULTS: map-entry->TikZ-seq
: ;;=> #'user/map-entry->TikZ-seq

#+RESULTS:
: #'user/map-entry->TikZ-seq

This method can now be used in order to create a TikZ standalone LaTeX
file, that is converted to a png file by the use of lualatex.

#+name: hash-map->TikZ-out
#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj

(defn hash-map->TikZ-out
  "Converts complete PDDL type hash-map to TikZ file"
  [h-map]
  (str
"\\documentclass[tikz]{standalone}

\\usepackage[utf8]{inputenc}

\\usepackage{tikz}

\\usetikzlibrary{graphdrawing}
\\usetikzlibrary{graphs}
\\usegdlibrary{layered,trees}

\\begin{document}

\\begin{tikzpicture}

\\graph[layered layout, nodes={draw,circle,fill=blue!20,font=\\bfseries}]
{
  " (clojure.string/join ",\n  " (map map-entry->TikZ-seq h-map))
"
};

\\end{tikzpicture}
\\end{document}"))

#+END_SRC

#+RESULTS: hash-map->TikZ-out
: ;;=> #'user/hash-map->TikZ-out

A resulting example image would look like this:

[[../img/tikz-file.pdf]]

This look can be further extended in order to create a 
UML class diagram for PDDL domains and problems:

At last, a main method is used, that allows for testing and running the
script. 

#+BEGIN_SRC clojure :tangle ./../src/org_ba/core.clj
  (defn -main
    "Runs the input/output scripts"
    [& args]
    (print
     (types->hash-map
      (split-up
       '(:types man woman - agent table bed - furniture robot agent))))
    (say/say "Welcome to PDDL environment"))
#+END_SRC

#+RESULTS:
: ;; CompilerException java.lang.RuntimeException: No such namespace: say, compiling:(/tmp/form-init8614017276071820586.clj:8:3) 
* Outtakes
** GraphVIZ + Pygments
#+BEGIN_EXAMPLE PDDL
  
  (define (domain xyz)
    (:requirements
     :strips))
  
#+END_EXAMPLE

#+BEGIN_SRC dot :file mygraph.png :exports results
digraph graph1  {
node [shape=box] 
       A -> B;
       D -> C;
       B -> D;
       E -> F;
}
  
#+END_SRC

#+RESULTS:
[[file:mygraph.png]]
